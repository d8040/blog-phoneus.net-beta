{"CSS":[{"id":1,"title":"SCSS(Sacc)정리?????","body":"CSS는 상대적으로 배우기 쉽고 재미있습니다.  \r\n웹 개발 초심자에게는 이만큼 접근하기 좋은 게 없죠.\r\n\r\nCSS는 분명 쉽고 재밌지만, 작업이 고도화될수록 불편함도 같이 커집니다.  \r\n불필요한 선택자(Selector)의 과용과 연산 기능의 한계, 구문(Statement)의 부재 등 프로젝트의 규모가 커질수록 아쉬움도 같이 커지죠.  \r\n하지만 웹에서는 표준 CSS만 동작할 수 있기 때문에 다른 선택권이 없습니다.\r\n\r\n그렇다면 우리는 앞으로 계속 CSS만 사용해야 할까요?\r\n\r\n# CSS Preprocessor 란?\r\n\r\nHTML, CSS를 다루는 분이라면 한 번은 들어봤을 Sass, Less 등이 있습니다.  \r\n이 친구들은 CSS 전(예비)처리기 입니다.  \r\n보통 CSS Preprocessor 라고 부릅니다.\r\n\r\nCSS가 동작하기 전에 사용하는 기능으로,  \r\n웹에서는 분명 CSS가 동작하지만 우리는 CSS의 불편함을 이런 확장 기능으로 상쇄할 수 있습니다.\r\n\r\n> 사스는 기초 언어에 힘과 우아함을 더해주는 CSS의 확장이다.\r\n\r\n### 어떻게 사용하나요?\r\n\r\n위에서 언급한 것처럼 웹에서는 CSS만 동작합니다.  \r\n[Sass](https://sass-lang.com/), [Less](http://lesscss.org/), [Stylus](http://stylus-lang.com/) 같은 전처리기(이하 ‘전처리기’로 표기)는 직접 동작시킬 수 없습니다.  \r\n그렇다면 어떻게 사용할 수 있을까요?\r\n\r\nCSS는 불편하니 일단 배제하고 우선 전처리기로 작성(코딩)합니다.  \r\n전처리기는 CSS 문법과 굉장히 유사하지만 선택자의 중첩(Nesting)이나 조건문, 반복문, 다양한 단위(Unit)의 연산 등… 표준 CSS 보다 훨씬 많은 기능을 사용해서 편리하게 작성할 수 있습니다.  \r\n단, 웹에서는 직접 동작하지 않으니 이렇게 작성한 전처리기를 웹에서 동작 가능한 표준의 CSS로 컴파일(Compile)합니다.  \r\n전처리기로 작성하고 CSS로 컴파일해서 동작시키는 거죠.\r\n\r\n### 컴파일은 어떻게 하나요?\r\n\r\n전처리기 종류마다 방법이 조금씩 다르고 여러 방식을 제공합니다.  \r\n보통의 경우 컴파일러(Compiler)가 필요합니다.  \r\n우리는 이제 Sass(SCSS)를 알아볼 것이고 컴파일 방법에 대해서도 같이 살펴보겠습니다.\r\n\r\n### 왜 Sass(SCSS)죠?\r\n\r\n보통 언급되는 전처리기 3대장으로 Less, Sass(SCSS), Stylus가 있습니다.\r\n\r\n저는 가장 많이 사용하고 진입장벽이 비교적 낮았던 Less를 처음 사용했습니다.  \r\n기본적인 기능은 전처리기들이 다 비슷합니다만 개인적으로 Less는 몇몇 기능에 큰 아쉬움이 있었습니다.  \r\n정확하게 언급하진 않겠지만 프로젝트 진행 중 Less에서 제공하는 기능의 한계로 막히는 경우가 몇 번 있었는데 그 기능이 Sass나 Stylus에는 있었습니다.  \r\n하지만 진입장벽이 낮기 때문에 접하기 쉽고 그만큼 많이 사용되는 듯합니다.\r\n\r\nStylus 같은 경우는 현재 이 블로그(HEROPY)를 만들면서 사용하고 있습니다.  \r\n깔끔하고 좀 더 세련됐으며 기능도 훌륭합니다.  \r\n하지만 덜 사용되며(덜 유명하며) 비교적 늦게 나왔기 때문에 성숙도는 떨어집니다.  \r\n그 때문인지 컴파일 후 사소한 버그가 몇몇 보입니다.\r\n\r\nSass(SCSS)는 언급한 두 가지 전처리기의 장점을 모두 가집니다.  \r\n문법은 Sass가 Stylus와 비슷하고, SCSS는 Less와 비슷하며, Sass와 SCSS는 하나의 컴파일러로 모두 컴파일 가능합니다.  \r\n또한, 2006년부터 시작하여 가장 오래된 CSS 확장 언어이며 그만큼 높은 성숙도와 많은 커뮤니티를 가지고 있고 기능도 훌륭합니다.  \r\n그래서 저는 Sass(SCSS)를 선택했습니다.\r\n\r\n### Sass와 SCSS는 차이점은 뭔가요?\r\n\r\nSass(Syntactically Awesome Style Sheets)의 3버전에서 새롭게 등장한 SCSS는 CSS 구문과 완전히 호환되도록 새로운 구문을 도입해 만든 Sass의 모든 기능을 지원하는 CSS의 상위집합(Superset) 입니다.  \r\n즉, SCSS는 CSS와 거의 같은 문법으로 Sass 기능을 지원한다는 말입니다.\r\n\r\n더 쉽고 간단한 차이는 `{}`(중괄호)와 `;`(세미콜론)의 유무입니다.  \r\n아래의 예제를 비교해 보세요.\r\n\r\nSass:\r\n\r\n```sass\r\n.list\r\n  width: 100px\r\n  float: left\r\n  li\r\n    color: red\r\n    background: url(\"./image.jpg\")\r\n    &:last-child\r\n      margin-right: -10px\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```scss\r\n.list {\r\n  width: 100px;\r\n  float: left;\r\n  li {\r\n    color: red;\r\n    background: url(\"./image.jpg\");\r\n    &:last-child {\r\n      margin-right: -10px;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nSass는 선택자의 유효범위를 ‘들여쓰기’로 구분하고, SCSS는 `{}`로 범위를 구분합니다.  \r\nSass 방식과 SCSS 방식 중 어떤 방식이 마음에 드세요?\r\n\r\n거의 유일합니다만, 다른 차이도 있습니다.  \r\n아래는 Mixins(‘믹스인’은 재사용 가능한 기능을 만드는 방식의 의미합니다) 예제입니다.  \r\nSass는 단축 구문으로 사용합니다.\r\n\r\n:Sass\r\n\r\n```sass\r\n=border-radius($radius)\r\n  -webkit-border-radius: $radius\r\n  -moz-border-radius:    $radius\r\n  -ms-border-radius:     $radius\r\n  border-radius:         $radius\r\n\r\n.box\r\n  +border-radius(10px)\r\n\r\n```\r\n\r\n:SCSS\r\n\r\n```scss\r\n@mixin border-radius($radius) {\r\n  -webkit-border-radius: $radius;\r\n     -moz-border-radius: $radius;\r\n      -ms-border-radius: $radius;\r\n          border-radius: $radius;\r\n}\r\n\r\n.box { @include border-radius(10px); }\r\n\r\n```\r\n\r\nSass는 `=`와 `+` 기호로 Mixins 기능을 사용했고,  \r\nSCSS는 `@mixin`과 `@include`로 기능을 사용했습니다.\r\n\r\n단순한 몇 가지를 제외하면 거의 차이가 없지만 복잡한 문장이 될 경우 여러 환경에 따른 장단점이 있을 수 있습니다.  \r\nSass는 좀 더 간결하고 작성하기 편리하며, `{}`나 `;`를 사용하지 않아도 되니 코드가 훨씬 깔끔해집니다.  \r\nSCSS는 인라인 코드(한 줄 작성)를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽습니다.\r\n\r\n이렇게 몇몇 장단점이 있기 때문에 회사나 팀에서 원하는 방식을 사용해야 하거나, 개인 취향에 따라서 선택할 수 있습니다.  \r\n단지 상황에 맞는, 원하는 방식으로 골라서 사용하면 됩니다.\r\n\r\n보통의 경우 SCSS를 추천합니다.\r\n\r\n# 컴파일 방법\r\n\r\nSass(SCSS)는 웹에서 직접 동작할 수 없습니다.  \r\n어디까지나 최종에는 표준 CSS로 동작해야 하며, 우리는 전처리기로 작성 후 CSS로 컴파일해야 합니다.  \r\n다양한 방법으로 컴파일이 가능하지만 자바스크립트 개발 환경([Node.js](https://nodejs.org/ko/))에서 추천하는 몇가지 방법을 소개합니다.\r\n\r\n### SassMeister\r\n\r\n간단한 Sass 코드는 컴파일러를 설치하는게 부담될 수 있습니다.  \r\n그럴 경우 [SassMeister](https://www.sassmeister.com/)를 사용할 수 있습니다.\r\n\r\n페이지 접속 후 바로 Sass나 SCSS 문법으로 코딩하면 CSS로 실시간 변환됩니다.  \r\nHTML를 작성하여 적용된 결과를 보거나 Sass 버전 설정 등 여러 환경 설정들을 지원하니 학습에 도움이 될 것입니다.\r\n\r\n### node-sass\r\n\r\n[node-sass](https://github.com/sass/node-sass)는 Node.js를 컴파일러인 [LibSass](https://sass-lang.com/libsass)에 바인딩한 라이브러리 입니다.  \r\nNPM으로 전역 설치하여 사용합니다.\r\n\r\n```sass\r\n$ npm install -g node-sass\r\n\r\n```\r\n\r\n컴파일하려는 파일의 경로와 컴파일된 파일이 저장될 경로를 설정합니다.  \r\n`[]`는 선택사항입니다.\r\n\r\n```sass\r\n$ node-sass [옵션] <입력파일경로> [출력파일경로]\r\n\r\n```\r\n\r\n```sass\r\n$ node-sass scss/main.scss public/main.css\r\n\r\n```\r\n\r\n여러 출력 경로를 설정할 수 있습니다.\r\n\r\n```sass\r\n$ node-sass scss/main.scss public/main.css dist/style.css\r\n\r\n```sass\r\n\r\n옵션을 적용할 수도 있습니다.  \r\n옵션으로 `--watch` 혹은 `-w`를 입력하면, 런타임 중 파일을 감시하여 저장 시 자동으로 변경 사항을 컴파일합니다.\r\n\r\n```sass\r\n$ node-sass --watch scss/main.scss public/main.css\r\n\r\n```\r\n\r\n기타 옵션은 [node-sass CLI](https://github.com/sass/node-sass#command-line-interface)에서 확인할 수 있습니다.\r\n\r\n### Gulp\r\n\r\n빌드 자동화 도구(JavaScript Task Runner)인 [Gulp](https://gulpjs.com/)에서는 `gulpfile.js`을 만들어 아래와 같이 설정할 수 있습니다.  \r\n먼저 `gulp` 명령을 사용하기 위해서는 전역 설치가 필요합니다.\r\n\r\n```sass\r\n$ npm install -g gulp\r\n\r\n```\r\n\r\nGulp와 함께 Sass 컴파일러인 [gulp-sass](https://github.com/dlmanning/gulp-sass)를 개발 의존성(devDependency) 모드로 설치합니다.  \r\ngulp-sass는 위에서 살펴본 node-sass를 Gulp에서 사용할 수 있도록 만들어진 플러그인입니다.\r\n\r\n```sass\r\n$ npm install --save-dev gulp gulp-sass\r\n\r\n```\r\n\r\n```java\r\n// gulpfile.js\r\nvar gulp = require('gulp')\r\nvar sass = require('gulp-sass')\r\n\r\n// 일반 컴파일\r\ngulp.task('sass', function () {\r\n  return gulp.src('./src/scss/*.scss')  // 입력 경로\r\n    .pipe(sass().on('error', sass.logError))\r\n    .pipe(gulp.dest('./dist/css'));  // 출력 경로\r\n});\r\n\r\n// 런타임 중 파일 감시\r\ngulp.task('sass:watch', function () {\r\n  gulp.watch('./src/scss/*.scss', ['sass']);  // 입력 경로와 파일 변경 감지 시 실행할 Actions(Task Name)\r\n});\r\n\r\n```\r\n\r\n환경을 설정했으니 컴파일합니다.\r\n\r\n```java\r\n$ gulp sass\r\n\r\n```\r\n\r\n런타임 중 파일 감시 모드로 실행할 수도 있습니다.\r\n\r\n```java\r\n$ gulp sass:watch\r\n\r\n```\r\n\r\n### Webpack\r\n\r\nJavaScript 모듈화 도구인 [Webpack](https://webpack.js.org/)의 설정은 좀 더 복잡합니다.  \r\n[Webpack - 1 - 시작하기 / EJS / SASS(SCSS)](https://heropy.blog/2017/10/18/webpack_1_start_ejs_sass/) 포스트를 참고하세요.\r\n\r\n### Parcel\r\n\r\n웹 애플리케이션 번들러 [Parcel](https://parceljs.org/)은 굉장히 단순하게 컴파일할 수 있습니다.  \r\n좀 더 자세한 내용은 [Parcel - 시작하기 / SASS / PostCSS / Babel / Production](https://heropy.blog/2018/01/20/parcel-1-start/)을 참고하세요.\r\n\r\n우선 Parcel를 전역으로 설치합니다.\r\n\r\n```java\r\n$ npm install -g parcel-bundler\r\n\r\n```\r\n\r\n프로젝트에 Sass 컴파일러(node-sass)를 설치합니다.\r\n\r\n```java\r\n$ npm install --save-dev node-sass\r\n\r\n```\r\n\r\n이제 HTML에 `<link>`로 Sass 파일만 연결하면 됩니다.  \r\n다른 설정은 필요하지 않습니다.\r\n\r\n```java\r\n<link rel=\"stylesheet\" href=\"scss/main.scss\">\r\n\r\n```\r\n\r\n```java\r\n$ parcel index.html\r\n# 혹은\r\n$ parcel build index.html\r\n\r\n```\r\n\r\n`dist/`에서 컴파일된 Sass 파일을 볼 수 있고,  \r\n별도의 포트 번호를 설정하지 않았다면 `[http://localhost:1234](http://localhost:1234)`에 접속하여 적용 상태를 확인할 수 있습니다.\r\n\r\n# 문법(Syntax)\r\n\r\n위의 ‘Sass와 SCSS의 차이점’에서 설명한대로 Sass와 SCSS의 기능은 동일하니, 편의를 위해 SCSS 문법으로 설명을 진행합니다.  \r\n단, Sass와 SCSS의 차이점이 있다면 나눠 설명합니다.\r\n\r\n## 주석(Comment)\r\n\r\nCSS 주석은 `/* ... */` 입니다.  \r\nSass(SCSS)는 JavaScript처럼 두 가지 스타일의 주석을 사용합니다.\r\n\r\n```css\r\n// 컴파일되지 않는 주석\r\n/* 컴파일되는 주석 */\r\n\r\n```\r\n\r\nSass의 경우 컴파일되는 여러 줄 주석을 사용할 때 각 줄 앞에 `*`을 붙여야 하고, 중요한 것은 `*`의 라인을 맞춰줘야 합니다.\r\n\r\nSass:\r\n\r\n```css\r\n/* 컴파일되는\r\n * 여러 줄\r\n * 주석 */\r\n\r\n// Error\r\n/* 컴파일되는\r\n* 여러 줄\r\n    * 주석 */\r\n\r\n```\r\n\r\nSCSS는 각 줄에 `*`이 없어도 문제되지 않습니다. 따라서 기존 CSS와 호환이 쉽습니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n/*\r\n컴파일되는\r\n여러 줄\r\n주석\r\n*/\r\n\r\n```\r\n\r\n## 데이터 종류(Data Types)\r\n\r\n| 데이터 | 설명 | 예시 |\r\n| --- | --- | --- |\r\n| Numbers | 숫자 | `1`, `.82`, `20px`, `2em`… |\r\n| Strings | 문자 | `bold`, `relative`, `\"/images/a.png\"`, `\"dotum\"` |\r\n| Colors | 색상 표현 | `red`, `blue`, `#FFFF00`, `rgba(255,0,0,.5)` |\r\n| Booleans | 논리 | `true`, `false` |\r\n| Nulls | 아무것도 없음 | `null` |\r\n| Lists | 공백이나 `,`로 구분된 값의 목록 | `(apple, orange, banana)`, `apple orange` |\r\n| Maps | Lists와 유사하나 값이 `Key: Value` 형태 | `(apple: a, orange: o, banana: b)` |\r\n\r\n### 특이사항\r\n\r\nSass에서 사용하는 데이터 종류들의 몇 가지 특이사항을 소개합니다.\r\n\r\n-   Numbers: 숫자에 단위가 있거나 없습니다.\r\n-   Strings: 문자에 따옴표가 있거나 없습니다.\r\n-   Nulls: 속성값으로 `null`이 사용되면 컴파일하지 않습니다.\r\n-   Lists: `()`를 붙이거나 붙이지 않습니다.\r\n-   Maps: `()`를 꼭 붙여야 합니다.\r\n\r\n## 중첩(Nesting)\r\n\r\nSass는 중첩 기능을 사용할 수 있습니다.  \r\n상위 선택자의 반복을 피하고 좀 더 편리하게 복잡한 구조를 작성할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n.section {\r\n  width: 100%;\r\n  .list {\r\n    padding: 20px;\r\n    li {\r\n      float: left;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```css\r\n.section {\r\n  width: 100%;\r\n}\r\n.section .list {\r\n  padding: 20px;\r\n}\r\n.section .list li {\r\n  float: left;\r\n}\r\n\r\n```\r\n\r\n### Ampersand (상위 선택자 참조)\r\n\r\n중첩 안에서 `&` 키워드는 상위(부모) 선택자를 참조하여 치환합니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n.btn {\r\n  position: absolute;\r\n  &.active {\r\n    color: red;\r\n  }\r\n}\r\n\r\n.list {\r\n  li {\r\n    &:last-child {\r\n      margin-right: 0;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.btn {\r\n  position: absolute;\r\n}\r\n.btn.active {\r\n  color: red;\r\n}\r\n.list li:last-child {\r\n  margin-right: 0;\r\n}\r\n\r\n```\r\n\r\n`&` 키워드가 참조한 상위 선택자로 치환되는 것이기 때문에 다음과 같이 응용할 수도 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.fs {\r\n  &-small { font-size: 12px; }\r\n  &-medium { font-size: 14px; }\r\n  &-large { font-size: 16px; }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fs-small {\r\n  font-size: 12px;\r\n}\r\n.fs-medium {\r\n  font-size: 14px;\r\n}\r\n.fs-large {\r\n  font-size: 16px;\r\n}\r\n\r\n```\r\n\r\n### @at-root (중첩 벗어나기)\r\n\r\n중첩에서 벗어나고 싶을 때 `@at-root` 키워드를 사용합니다.  \r\n중첩 안에서 생성하되 중첩 밖에서 사용해야 경우에 유용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.list {\r\n  $w: 100px;\r\n  $h: 50px;\r\n  li {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n  @at-root .box {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.list li {\r\n  width: 100px;\r\n  height: 50px;\r\n}\r\n.box {\r\n  width: 100px;\r\n  height: 50px;\r\n}\r\n\r\n```\r\n\r\n아래 예제 처럼 `.list` 안에 있는 특정 변수를 범위 밖에서 사용할 수 없기 때문에, 위 예제 처럼 `@at-root` 키워드를 사용해야 합니다.(변수는 아래에서 설명합니다)\r\n\r\n```\r\n.list {\r\n  $w: 100px;\r\n  $h: 50px;\r\n  li {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n}\r\n\r\n// Error\r\n.box {\r\n  width: $w;\r\n  height: $h;\r\n}\r\n\r\n```\r\n\r\n### 중첩된 속성\r\n\r\n`font-`, `margin-` 등과 같이 동일한 네임 스페이스를 가지는 속성들을 다음과 같이 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.box {\r\n  font: {\r\n    weight: bold;\r\n    size: 10px;\r\n    family: sans-serif;\r\n  };\r\n  margin: {\r\n    top: 10px;\r\n    left: 20px;\r\n  };\r\n  padding: {\r\n    bottom: 40px;\r\n    right: 30px;\r\n  };\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  font-weight: bold;\r\n  font-size: 10px;\r\n  font-family: sans-serif;\r\n  margin-top: 10px;\r\n  margin-left: 20px;\r\n  padding-bottom: 40px;\r\n  padding-right: 30px;\r\n}\r\n\r\n```\r\n\r\n## 변수(Variables)\r\n\r\n반복적으로 사용되는 값을 변수로 지정할 수 있습니다.  \r\n변수 이름 앞에는 항상 `$`를 붙입니다.\r\n\r\n```\r\n$변수이름: 속성값;\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$color-primary: #e96900;\r\n$url-images: \"/assets/images/\";\r\n$w: 200px;\r\n\r\n.box {\r\n  width: $w;\r\n  margin-left: $w;\r\n  background: $color-primary url($url-images + \"bg.jpg\");\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  width: 200px;\r\n  margin-left: 200px;\r\n  background: #e96900 url(\"/assets/images/bg.jpg\");\r\n}\r\n\r\n```\r\n\r\n### 변수 유효범위(Variable Scope)\r\n\r\n변수는 사용 가능한 유효범위가 있습니다.  \r\n선언된 블록(`{}`) 내에서만 유효범위를 가집니다.\r\n\r\n변수 `$color`는 `.box1`의 블록 안에서 설정되었기 때문에, 블록 밖의 `.box2`에서는 사용할 수 없습니다.\r\n\r\n```\r\n.box1 {\r\n  $color: #111;\r\n  background: $color;\r\n}\r\n// Error\r\n.box2 {\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\n### 변수 재 할당(Variable Reassignment)\r\n\r\n다음과 같이 변수에 변수를 할당할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$red: #FF0000;\r\n$blue: #0000FF;\r\n\r\n$color-primary: $blue;\r\n$color-danger: $red;\r\n\r\n.box {\r\n  color: $color-primary;\r\n  background: $color-danger;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  color: #0000FF;\r\n  background: #FF0000;\r\n}\r\n\r\n```\r\n\r\n### !global (전역 설정)\r\n\r\n`!global` 플래그를 사용하면 변수의 유효범위를 전역(Global)로 설정할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.box1 {\r\n  $color: #111 !global;\r\n  background: $color;\r\n}\r\n.box2 {\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  background: #111;\r\n}\r\n.box2 {\r\n  background: #111;\r\n}\r\n\r\n```\r\n\r\n대신 기존에 사용하던 같은 이름의 변수가 있을 경우 값이 덮어져 사용될 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color: #000;\r\n.box1 {\r\n  $color: #111 !global;\r\n  background: $color;\r\n}\r\n.box2 {\r\n  background: $color;\r\n}\r\n.box3 {\r\n  $color: #222;\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  background: #111;\r\n}\r\n.box2 {\r\n  background: #111;\r\n}\r\n.box3 {\r\n  background: #222;\r\n}\r\n\r\n```\r\n\r\n### !default (초깃값 설정)\r\n\r\n`!default` 플래그는 할당되지 않은 변수의 초깃값을 설정합니다.  \r\n즉, 할당되어있는 변수가 있다면 변수가 기존 할당 값을 사용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color-primary: red;\r\n\r\n.box {\r\n  $color-primary: blue !default;\r\n  background: $color-primary;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\n좀 더 유용하게, ‘변수와 값을 설정하겠지만, 혹시 기존 변수가 있을 경우는 현재 설정하는 변수의 값은 사용하지 않겠다’는 의미로 쓸 수 있습니다.  \r\n예를 들어, [Bootstrap](https://github.com/twbs/bootstrap/tree/v4-dev/scss) 같은 외부 Sass(SCSS) 라이브러리를 연결했더니 변수 이름이 같아 내가 작성한 코드의 변수들이 Overwrite(덮어쓰기) 된다면 문제가 있겠죠.  \r\n반대로 내가 만든 Sass(SCSS) 라이브러리가 다른 사용자 코드의 변수들을 Overwrite 한다면, 사용자들은 그 라이브러리를 더 이상 사용하지 않을 것입니다.  \r\n이럴 때 Sass(SCSS) 라이브러리(혹은 새롭게 만든 모듈)에서 사용하는 변수에 `!default` 플래그가 있다면 기존 코드(원본)를 Overwrite 하지 않고도 사용할 수 있습니다.\r\n\r\n```\r\n// _config.scss\r\n$color-active: red;\r\n\r\n```\r\n\r\n```\r\n// main.scss\r\n@import 'config';\r\n\r\n$color-active: blue !default;\r\n\r\n.box {\r\n  background: $color-active;  // red\r\n}\r\n\r\n```\r\n\r\n다음은 Bootstrap 코드([\\_variables.scss](https://github.com/twbs/bootstrap/blob/v4-dev/scss/_variables.scss))의 일부입니다.\r\n\r\n<script src=\"https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d.js\"></script>\r\n\r\n<table class=\"highlight tab-size js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\"><tbody><tr><td id=\"file-_variables-scss-L1\" class=\"blob-num js-line-number\" data-line-number=\"1\">&nbsp;</td><td id=\"file-_variables-scss-LC1\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-c\"><span class=\"pl-c\">//</span> stylelint-disable</span></td></tr><tr><td id=\"file-_variables-scss-L2\" class=\"blob-num js-line-number\" data-line-number=\"2\">&nbsp;</td><td id=\"file-_variables-scss-LC2\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$white</span>: <span class=\"pl-c1\">#fff</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L3\" class=\"blob-num js-line-number\" data-line-number=\"3\">&nbsp;</td><td id=\"file-_variables-scss-LC3\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-100</span>: <span class=\"pl-c1\">#f8f9fa</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L4\" class=\"blob-num js-line-number\" data-line-number=\"4\">&nbsp;</td><td id=\"file-_variables-scss-LC4\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-200</span>: <span class=\"pl-c1\">#e9ecef</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L5\" class=\"blob-num js-line-number\" data-line-number=\"5\">&nbsp;</td><td id=\"file-_variables-scss-LC5\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-300</span>: <span class=\"pl-c1\">#dee2e6</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L6\" class=\"blob-num js-line-number\" data-line-number=\"6\">&nbsp;</td><td id=\"file-_variables-scss-LC6\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-400</span>: <span class=\"pl-c1\">#ced4da</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L7\" class=\"blob-num js-line-number\" data-line-number=\"7\">&nbsp;</td><td id=\"file-_variables-scss-LC7\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-500</span>: <span class=\"pl-c1\">#adb5bd</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L8\" class=\"blob-num js-line-number\" data-line-number=\"8\">&nbsp;</td><td id=\"file-_variables-scss-LC8\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-600</span>: <span class=\"pl-c1\">#6c757d</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L9\" class=\"blob-num js-line-number\" data-line-number=\"9\">&nbsp;</td><td id=\"file-_variables-scss-LC9\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-700</span>: <span class=\"pl-c1\">#495057</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L10\" class=\"blob-num js-line-number\" data-line-number=\"10\">&nbsp;</td><td id=\"file-_variables-scss-LC10\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-800</span>: <span class=\"pl-c1\">#343a40</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L11\" class=\"blob-num js-line-number\" data-line-number=\"11\">&nbsp;</td><td id=\"file-_variables-scss-LC11\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-900</span>: <span class=\"pl-c1\">#212529</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L12\" class=\"blob-num js-line-number\" data-line-number=\"12\">&nbsp;</td><td id=\"file-_variables-scss-LC12\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$black</span>: <span class=\"pl-c1\">#000</span> <span class=\"pl-k\">!default</span>;</td></tr></tbody></table>\r\n\r\n[view raw](https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d/raw/d1f8a93d7397ca4365feb29a2ede41653271a365/_variables.scss) [\\_variables.scss](https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d#file-_variables-scss) hosted with ❤ by [GitHub](https://github.com)\r\n\r\n### #{} (문자 보간)\r\n\r\n`#{}`를 이용해서 코드의 어디든지 변수 값을 넣을 수 있습니다.\r\n\r\n```\r\n$family: unquote(\"Droid+Sans\");\r\n@import url(\"http://fonts.googleapis.com/css?family=#{$family}\");\r\n\r\n```\r\n\r\n```\r\n@import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\");\r\n\r\n```\r\n\r\nSass의 내장 함수 `unquote()`는 문자에서 따옴표를 제거합니다.\r\n\r\n## 가져오기(Import)\r\n\r\n`@import`로 외부에서 가져온 Sass 파일은 모두 단일 CSS 출력 파일로 병합됩니다.  \r\n또한, 가져온 파일에 정의된 모든 변수 또는 Mixins 등을 주 파일에서 사용할 수 있습니다.\r\n\r\nSass `@import`는 기본적으로 Sass 파일을 가져오는데, CSS `@import` 규칙으로 컴파일되는 몇 가지 상황이 있습니다.\r\n\r\n-   파일 확장자가 `.css`일 때\r\n-   파일 이름이 `http://`로 시작하는 경우\r\n-   `url()`이 붙었을 경우\r\n-   미디어쿼리가 있는 경우\r\n\r\n위의 경우 CSS `@import` 규칙대로 컴파일 됩니다.\r\n\r\n```\r\n@import \"hello.css\";\r\n@import \"http://hello.com/hello\";\r\n@import url(hello);\r\n@import \"hello\" screen;\r\n\r\n```\r\n\r\n### 여러 파일 가져오기\r\n\r\n하나의 `@import`로 여러 파일을 가져올 수도 있습니다.  \r\n파일 이름은 `,`로 구분합니다.\r\n\r\n```\r\n@import \"header\", \"footer\";\r\n\r\n```\r\n\r\n### 파일 분할(Partials)\r\n\r\n프로젝트 규모가 커지면 파일들을 `header`나 `side-menu` 같이 각 기능과 부분으로 나눠 유지보수가 쉽도록 관리하게 됩니다.  \r\n이 경우 파일이 점점 많아지는데, 모든 파일이 컴파일 시 각각의 `~.css` 파일로 나눠서 저장된다면 관리나 성능 차원에서 문제가 될 수 있겠죠.  \r\n그래서 Sass는 Partials 기능을 지원합니다.  \r\n파일 이름 앞에 `_`를 붙여(`_header.scss`와 같이) `@import`로 가져오면 컴파일 시 `~.css` 파일로 컴파일하지 않습니다.\r\n\r\n예를 들어보겠습니다.  \r\n다음과 같이 `scss/` 안에 3개의 Sass 파일이 있습니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n`main.scss`로 나머지 `~.scss` 파일을 가져옵니다.\r\n\r\n```\r\n// main.scss\r\n@import \"header\", \"side-menu\";\r\n\r\n```\r\n\r\n그리고 이 파일들을 `css/`디렉토리로 컴파일합니다.  \r\n(컴파일은 위에서 설명한 `node-sass`로 진행합니다.)\r\n\r\n```\r\n# `scss`디렉토리에 있는 파일들을 `css`디렉토리로 컴파일\r\n$ node-sass scss --output css\r\n\r\n```\r\n\r\n컴파일 후 확인하면 아래와 같이 `scss/`에 있던 파일들이 `css/` 안에 각 하나씩의 파일로 컴파일됩니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─css\r\n  │  ├─header.css\r\n  │  ├─side-menu.css\r\n  │  └─main.css\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n자, 이번에는 가져올 파일 이름에 `_`를 붙이겠습니다.  \r\n메인 파일인 `main.scss`에서는 `_`를 사용하지 않습니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─scss\r\n  │  ├─_header.scss\r\n  │  ├─_side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n```\r\n// main.scss\r\n@import \"header\", \"side-menu\";\r\n\r\n```\r\n\r\n같은 방법으로 컴파일하면…\r\n\r\n```\r\n$ node-sass scss --output css\r\n\r\n```\r\n\r\n아래처럼 별도의 파일로 컴파일되지 않고 사용됩니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─css\r\n  │  └─main.css  # main + header + side-menu\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n`Webpack`이나 `Parcel`, `Gulp` 같은 일반적인 빌드툴에서는 Partials 기능을 사용할 필요 없이, 설정된 값에 따라 빌드됩니다. 하지만 되도록 `_`를 사용할 것을 권장합니다.\r\n\r\n## 연산(Operations)\r\n\r\nSass는 기본적인 연산 기능을 지원합니다.  \r\n레이아웃 작업시 상황에 맞게 크기를 계산을 하거나 정해진 값을 나눠서 작성할 경우 유용합니다.  \r\n다음은 Sass에서 사용 가능한 연산자 종류 입니다.\r\n\r\n산술 연산자:\r\n\r\n| 종류 | 설명 | 주의사항 |\r\n| --- | --- | --- |\r\n| `+` | 더하기 |   |\r\n| `-` | 빼기 |   |\r\n| `*` | 곱하기 | 하나 이상의 값이 반드시 숫자(Number) |\r\n| `/` | 나누기 | 오른쪽 값이 반드시 숫자(Number) |\r\n| `%` | 나머지 |   |\r\n\r\n비교 연산자:\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `==` | 동등 |\r\n| `!=` | 부등 |\r\n| `<` | 대소 / 보다 작은 |\r\n| `>` | 대소 / 보다 큰 |\r\n| `<=` | 대소 및 동등 / 보다 작거나 같은 |\r\n| `>=` | 대소 및 동등 / 보다 크거나 같은 |\r\n\r\n논리(불린, Boolean) 연산자:\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `and` | 그리고 |\r\n| `or` | 또는 |\r\n| `not` | 부정 |\r\n\r\n### 숫자(Numbers)\r\n\r\n#### 상대적 단위 연산\r\n\r\n일반적으론 절댓값을 나타내는 `px` 단위로 연산을 합니다만, 상대적 단위(`%`, `em`, `vw` 등)의 연산의 경우 [CSS calc()](https://developer.mozilla.org/ko/docs/Web/CSS/calc)로 연산해야 합니다.\r\n\r\n```\r\nwidth: 50% - 20px;  // 단위 모순 에러(Incompatible units error)\r\nwidth: calc(50% - 20px);  // 연산 가능\r\n\r\n```\r\n\r\n#### 나누기 연산의 주의사항\r\n\r\nCSS는 속성 값의 숫자를 분리하는 방법으로 `/`를 허용하기 때문에 `/`가 나누기 연산으로 사용되지 않을 수 있습니다.  \r\n예를 들어, `font: 16px / 22px serif;` 같은 경우 `font-size: 16px`와 `line-height: 22px`의 속성값 분리를 위해서 `/`를 사용합니다.  \r\n아래 예제를 보면 나누기 연산자만 연산 되지 않고 그대로 컴파일됩니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  width: 20px + 20px;  // 더하기\r\n  height: 40px - 10px;  // 빼기\r\n  font-size: 10px * 2;  // 곱하기\r\n  margin: 30px / 2;  // 나누기\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 40px;  /* OK */\r\n  height: 30px;  /* OK */\r\n  font-size: 20px;  /* OK */\r\n  margin: 30px / 2;  /* ?? */\r\n}\r\n\r\n```\r\n\r\n따라서 `/`를 나누기 연산 기능으로 사용하려면 다음과 같은 조건을 충족해야 합니다.\r\n\r\n-   값 또는 그 일부가 변수에 저장되거나 함수에 의해 반환되는 경우\r\n-   값이 `()`로 묶여있는 경우\r\n-   값이 다른 산술 표현식의 일부로 사용되는 경우\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  $x: 100px;\r\n  width: $x / 2;  // 변수에 저장된 값을 나누기\r\n  height: (100px / 2);  // 괄호로 묶어서 나누기\r\n  font-size: 10px + 12px / 3;  // 더하기 연산과 같이 사용\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 50px;\r\n  height: 50px;\r\n  font-size: 14px;\r\n}\r\n\r\n```\r\n\r\n### 문자(Strings)\r\n\r\n문자 연산에는 `+`가 사용됩니다.  \r\n문자 연산의 결과는 첫 번째 피연산자를 기준으로 합니다.  \r\n첫 번째 피연산자에 따옴표가 붙어있다면 연산 결과를 따옴표로 묶습니다.  \r\n반대로 첫 번째 피연산자에 따옴표가 붙어있지 않다면 연산 결과도 따옴표를 처리하지 않습니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv::after {\r\n  content: \"Hello \" + World;\r\n  flex-flow: row + \"-reverse\" + \" \" + wrap\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv::after {\r\n  content: \"Hello World\";\r\n  flex-flow: row-reverse wrap;\r\n}\r\n\r\n```\r\n\r\n### 색상(Colors)\r\n\r\n색상도 연산할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  color: #123456 + #345678;\r\n  // R: 12 + 34 = 46\r\n  // G: 34 + 56 = 8a\r\n  // B: 56 + 78 = ce\r\n  background: rgba(50, 100, 150, .5) + rgba(10, 20, 30, .5);\r\n  // R: 50 + 10 = 60\r\n  // G: 100 + 20 = 120\r\n  // B: 150 + 30 = 180\r\n  // A: Alpha channels must be equal\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: #468ace;\r\n  background: rgba(60, 120, 180, 0.5);\r\n}\r\n\r\n```\r\n\r\nRGBA에서 Alpha 값은 연산되지 않으며 서로 동일해야 다른 값의 연산이 가능합니다.  \r\nAlpha 값을 연산하기 위한 다음과 같은 색상 함수(Color Functions)를 사용할 수 있습니다.\r\n\r\n[opacify()](http://sass-lang.com/documentation/Sass/Script/Functions.html#opacify-instance_method), [transparentize()](http://sass-lang.com/documentation/Sass/Script/Functions.html#transparentize-instance_method)\r\n\r\nSCSS:\r\n\r\n```\r\n$color: rgba(10, 20, 30, .5);\r\ndiv {\r\n  color: opacify($color, .3);  // 30% 더 불투명하게 / 0.5 + 0.3\r\n  background-color: transparentize($color, .2);  // 20% 더 투명하게 / 0.5 - 0.2\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: rgba(10, 20, 30, 0.8);\r\n  background-color: rgba(10, 20, 30, 0.3);\r\n}\r\n\r\n```\r\n\r\n### 논리(Boolean)\r\n\r\nSass의 `@if` 조건문에서 사용되는 논리(Boolean) 연산에는 ‘그리고’,’ 또는’, ‘부정’이 있습니다.  \r\n자바스크립트 문법에 익숙하다면 `&&`, `||`, `!`와 같은 기능으로 생각하면 됩니다.\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `and` | 그리고 |\r\n| `or` | 또는 |\r\n| `not` | 부정(반대) |\r\n\r\n간단한 예제를 확인하고, 더 자세한 내용은 조건문에서 살펴보겠습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$width: 90px;\r\ndiv {\r\n  @if not ($width > 100px) {\r\n    height: 300px;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  height: 300px;\r\n}\r\n\r\n```\r\n\r\n## 재활용(Mixins)\r\n\r\nSass Mixins는 스타일 시트 전체에서 **재사용 할 CSS 선언 그룹** 을 정의하는 아주 훌륭한 기능입니다.  \r\n약간의 Mixin(믹스인)으로 다양한 스타일을 만들어낼 수 있습니다.\r\n\r\n우선, Mixin은 두 가지만 기억하면 됩니다.  \r\n선언하기(`@mixin`)와 포함하기(`@include`) 입니다.  \r\n만들어서(선언), 사용(포함)하는 거죠!\r\n\r\n### @mixin\r\n\r\n기본적인 Mixin 선언은 아주 간단합니다.  \r\n`@mixin` 지시어를 이용하여 스타일을 정의합니다.\r\n\r\n```\r\n// SCSS\r\n@mixin 믹스인이름 {\r\n  스타일;\r\n}\r\n\r\n// Sass\r\n=믹스인이름\r\n  스타일\r\n\r\n```\r\n\r\n```\r\n// SCSS\r\n@mixin large-text {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\n\r\n// Sass\r\n=large-text\r\n  font-size: 22px\r\n  font-weight: bold\r\n  font-family: sans-serif\r\n  color: orange\r\n\r\n```\r\n\r\nMixin은 선택자를 포함 가능하고 상위(부모) 요소 참조(`&` 같은)도 할 수 있습니다.\r\n\r\n```\r\n@mixin large-text {\r\n  font: {\r\n    size: 22px;\r\n    weight: bold;\r\n    family: sans-serif;\r\n  }\r\n  color: orange;\r\n\r\n  &::after {\r\n    content: \"!!\";\r\n  }\r\n\r\n  span.icon {\r\n    background: url(\"/images/icon.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n### @include\r\n\r\n선언된 Mixin을 사용(포함)하기 위해서는 `@include`가 필요합니다.  \r\n위에서 선언한 Mixin을 사용해 보겠습니다.\r\n\r\n```\r\n// SCSS\r\n@include 믹스인이름;\r\n\r\n// Sass\r\n+믹스인이름\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n// SCSS\r\nh1 {\r\n  @include large-text;\r\n}\r\ndiv {\r\n  @include large-text;\r\n}\r\n\r\n// Sass\r\nh1\r\n  +large-text\r\ndiv\r\n  +large-text\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\nh1 {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\nh1::after {\r\n  content: \"!!\";\r\n}\r\nh1 span.icon {\r\n  background: url(\"/images/icon.png\");\r\n}\r\n\r\ndiv {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\ndiv::after {\r\n  content: \"!!\";\r\n}\r\ndiv span.icon {\r\n  background: url(\"/images/icon.png\");\r\n}\r\n\r\n```\r\n\r\n### 인수(Arguments)\r\n\r\nMixin은 함수(Functions)처럼 인수(Arguments)를 가질 수 있습니다.  \r\n하나의 Mixin으로 다양한 결과를 만들 수 있습니다.\r\n\r\n```\r\n// SCSS\r\n@mixin 믹스인이름($매개변수) {\r\n  스타일;\r\n}\r\n@include 믹스인이름(인수);\r\n\r\n// Sass\r\n=믹스인이름($매개변수)\r\n  스타일\r\n\r\n+믹스인이름(인수)\r\n\r\n```\r\n\r\n> 매개변수(Parameters)란 변수의 한 종류로, 제공되는 여러 데이터 중 하나를 가리키기 위해 사용된다.  \r\n> 제공되는 여러 데이터들을 전달인수(Arguments) 라고 부른다.\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin dash-line($width, $color) {\r\n  border: $width dashed $color;\r\n}\r\n\r\n.box1 { @include dash-line(1px, red); }\r\n.box2 { @include dash-line(4px, blue); }\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  border: 1px dashed red;\r\n}\r\n.box2 {\r\n  border: 4px dashed blue;\r\n}\r\n\r\n```\r\n\r\n#### 인수의 기본값 설정\r\n\r\n인수(argument)는 기본값(default value)을 가질 수 있습니다.  \r\n`@include` 포함 단계에서 별도의 인수가 전달되지 않으면 기본값이 사용됩니다.\r\n\r\n```\r\n@mixin 믹스인이름($매개변수: 기본값) {\r\n  스타일;\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin dash-line($width: 1px, $color: black) {\r\n  border: $width dashed $color;\r\n}\r\n\r\n.box1 { @include dash-line; }\r\n.box2 { @include dash-line(4px); }\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  border: 1px dashed black;\r\n}\r\n.box2 {\r\n  border: 4px dashed black;\r\n}\r\n\r\n```\r\n\r\n#### 키워드 인수(Keyword Arguments)\r\n\r\n```\r\n@mixin 믹스인이름($매개변수A: 기본값, $매개변수B: 기본값) {\r\n  스타일;\r\n}\r\n\r\n@include 믹스인이름($매개변수B: 인수);\r\n\r\n```\r\n\r\nMixin에 전달할 인수를 입력할 때 명시적으로 키워드(변수)를 입력하여 작성할 수 있습니다.  \r\n별도의 인수 입력 순서를 필요로 하지 않아 편리하게 작성할 수 있습니다.  \r\n단, 작성하지 않은 인수가 적용될 수 있도록 기본값을 설정해 주는 것이 좋습니다.\r\n\r\n```\r\n@mixin position(\r\n  $p: absolute,\r\n  $t: null,\r\n  $b: null,\r\n  $l: null,\r\n  $r: null\r\n) {\r\n  position: $p;\r\n  top: $t;\r\n  bottom: $b;\r\n  left: $l;\r\n  right: $r;\r\n}\r\n\r\n.absolute {\r\n  // 키워드 인수로 설정할 값만 전달\r\n  @include position($b: 10px, $r: 20px);\r\n}\r\n.fixed {\r\n  // 인수가 많아짐에 따라 가독성을 확보하기 위해 줄바꿈\r\n  @include position(\r\n    fixed,\r\n    $t: 30px,\r\n    $r: 40px\r\n  );\r\n}\r\n\r\n```\r\n\r\n```\r\n.absolute {\r\n  position: absolute;\r\n  bottom: 10px;\r\n  right: 20px;\r\n}\r\n.fixed {\r\n  position: fixed;\r\n  top: 30px;\r\n  right: 40px;\r\n}\r\n\r\n```\r\n\r\n#### 가변 인수(Variable Arguments)\r\n\r\n때때로 입력할 인수의 개수가 불확실한 경우가 있습니다.  \r\n그럴 경우 가변 인수를 사용할 수 있습니다.  \r\n가변 인수는 매개변수 뒤에 `...`을 붙여줍니다.\r\n\r\n```\r\n@mixin 믹스인이름($매개변수...) {\r\n  스타일;\r\n}\r\n\r\n@include 믹스인이름(인수A, 인수B, 인수C);\r\n\r\n```\r\n\r\n```\r\n// 인수를 순서대로 하나씩 전달 받다가, 3번째 매개변수($bg-values)는 인수의 개수에 상관없이 받음\r\n@mixin bg($width, $height, $bg-values...) {\r\n  width: $width;\r\n  height: $height;\r\n  background: $bg-values;\r\n}\r\n\r\ndiv {\r\n  // 위의 Mixin(bg) 설정에 맞게 인수를 순서대로 전달하다가 3번째 이후부터는 개수에 상관없이 전달\r\n  @include bg(\r\n    100px,\r\n    200px,\r\n    url(\"/images/a.png\") no-repeat 10px 20px,\r\n    url(\"/images/b.png\") no-repeat,\r\n    url(\"/images/c.png\")\r\n  );\r\n}\r\n\r\n```\r\n\r\n```\r\ndiv {\r\n  width: 100px;\r\n  height: 200px;\r\n  background: url(\"/images/a.png\") no-repeat 10px 20px,\r\n              url(\"/images/b.png\") no-repeat,\r\n              url(\"/images/c.png\");\r\n}\r\n\r\n```\r\n\r\n위에선 인수를 받는 매개변수에 `...`을 사용하여 가변 인수를 활용했습니다.  \r\n이번엔 반대로 가변 인수를 전달할 값으로 사용해 보겠습니다.\r\n\r\n```\r\n@mixin font(\r\n  $style: normal,\r\n  $weight: normal,\r\n  $size: 16px,\r\n  $family: sans-serif\r\n) {\r\n  font: {\r\n    style: $style;\r\n    weight: $weight;\r\n    size: $size;\r\n    family: $family;\r\n  }\r\n}\r\ndiv {\r\n  // 매개변수 순서와 개수에 맞게 전달\r\n  $font-values: italic, bold, 16px, sans-serif;\r\n  @include font($font-values...);\r\n}\r\nspan {\r\n  // 필요한 값만 키워드 인수로 변수에 담아 전달\r\n  $font-values: (style: italic, size: 22px);\r\n  @include font($font-values...);\r\n}\r\na {\r\n  // 필요한 값만 키워드 인수로 전달\r\n  @include font((weight: 900, family: monospace)...);\r\n}\r\n\r\n```\r\n\r\n```\r\ndiv {\r\n  font-style: italic;\r\n  font-weight: bold;\r\n  font-size: 16px;\r\n  font-family: sans-serif;\r\n}\r\nspan {\r\n  font-style: italic;\r\n  font-weight: normal;\r\n  font-size: 22px;\r\n  font-family: sans-serif;\r\n}\r\na {\r\n  font-style: normal;\r\n  font-weight: 900;\r\n  font-size: 16px;\r\n  font-family: monospace;\r\n}\r\n\r\n```\r\n\r\n### @content\r\n\r\n선언된 Mixin에 `@content`이 포함되어 있다면 해당 부분에 원하는 **스타일 블록** 을 전달할 수 있습니다.  \r\n이 방식을 사용하여 기존 Mixin이 가지고 있는 기능에 선택자나 속성 등을 추가할 수 있습니다.\r\n\r\n```\r\n@mixin 믹스인이름() {\r\n  스타일;\r\n  @content;\r\n}\r\n\r\n@include 믹스인이름() {\r\n  // 스타일 블록\r\n  스타일;\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin icon($url) {\r\n  &::after {\r\n    content: $url;\r\n    @content;\r\n  }\r\n}\r\n.icon1 {\r\n  // icon Mixin의 기존 기능만 사용\r\n  @include icon(\"/images/icon.png\");\r\n}\r\n.icon2 {\r\n  // icon Mixin에 스타일 블록을 추가하여 사용\r\n  @include icon(\"/images/icon.png\") {\r\n    position: absolute;\r\n  };\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.icon1::after {\r\n  content: \"/images/icon.png\";\r\n}\r\n.icon2::after {\r\n  content: \"/images/icon.png\";\r\n  position: absolute;\r\n}\r\n\r\n```\r\n\r\nMixin에게 전달된 스타일 블록은 Mixin의 범위가 아니라 스타일 블록이 정의된 범위에서 평가됩니다.  \r\n즉, Mixin의 매개변수는 전달된 스타일 블록 안에서 사용되지 않고 전역 값으로 해석됩니다.  \r\n전역 변수(Global variables)와 지역 변수(Local variables)를 생각하면 좀 더 쉽습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color: red;\r\n\r\n@mixin colors($color: blue) {\r\n  // Mixin의 범위\r\n  @content;\r\n  background-color: $color;\r\n  border-color: $color;\r\n}\r\n\r\ndiv {\r\n  @include colors() {\r\n    // 스타일 블록이 정의된 범위\r\n    color: $color;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: red;\r\n  background-color: blue;\r\n  border-color: blue;\r\n}\r\n\r\n```\r\n\r\n## 확장(Extend)\r\n\r\n특정 선택자가 다른 선택자의 모든 스타일을 가져야하는 경우가 종종 있습니다.  \r\n이럴 경우 선택자의 확장 기능을 사용할 수 있습니다.  \r\n다음 예제를 봅시다.\r\n\r\n```\r\n@extend 선택자;\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n.btn {\r\n  padding: 10px;\r\n  margin: 10px;\r\n  background: blue;\r\n}\r\n.btn-danger {\r\n  @extend .btn;\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.btn, .btn-danger {\r\n  padding: 10px;\r\n  margin: 10px;\r\n  background: blue;\r\n}\r\n.btn-danger {\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\n컴파일된 결과가 마음에 드시나요?  \r\n결과를 보면 `,`로 구분하는 다중 선택자(Multiple Selector)가 만들어졌습니다.\r\n\r\n사실 `@extend`는 다음과 같은 문제를 고려해야 합니다.\r\n\r\n-   내 현재 선택자(위 예제의 `.btn-danger`)가 어디에 첨부될 것인가?\r\n-   원치 않는 부작용이 초래될 수도 있는가?\r\n-   이 한 번의 확장으로 얼마나 큰 CSS가 생성되는가?\r\n\r\n결과적으로 확장(Extend) 기능은 무해하거나 혹은 유익할 수도 있지만 그만큼 **부작용**을 가지고 있을 수 있습니다.  \r\n따라서 확장은 사용을 권장하지 않으며, 위에서 살펴본 **Mixin을 대체 기능으로 사용**하세요.\r\n\r\n사용을 권장하지 않는 이유에 대해서 좀 더 자세한 정보를 원하면 [Sass Guidelines Extend](https://sass-guidelin.es/ko/#extend)를 참고하세요.\r\n\r\n## 함수(Functions)\r\n\r\n자신의 함수를 정의하여 사용할 수 있습니다.  \r\n함수와 Mixins은 거의 유사하지만 반환되는 내용이 다릅니다.\r\n\r\nMixin은 위에서 살펴본 대로 지정한 스타일(Style)을 반환하는 반면,  \r\n함수는 보통 연산된(Computed) 특정 **값**을 `@return` 지시어를 통해 반환합니다.\r\n\r\n```\r\n// Mixins\r\n@mixin 믹스인이름($매개변수) {\r\n  스타일;\r\n}\r\n\r\n// Functions\r\n@function 함수이름($매개변수) {\r\n  @return 값\r\n}\r\n\r\n```\r\n\r\n사용하는 방법에도 차이가 있습니다.  \r\nMixin은 `@include` 지시어를 사용하는 반면,  \r\n함수는 함수이름으로 바로 사용합니다.\r\n\r\n```\r\n// Mixin\r\n@include 믹스인이름(인수);\r\n\r\n// Functions\r\n함수이름(인수)\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$max-width: 980px;\r\n\r\n@function columns($number: 1, $columns: 12) {\r\n  @return $max-width * ($number / $columns)\r\n}\r\n\r\n.box_group {\r\n  width: $max-width;\r\n\r\n  .box1 {\r\n    width: columns();  // 1\r\n  }\r\n  .box2 {\r\n    width: columns(8);\r\n  }\r\n  .box3 {\r\n    width: columns(3);\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box_group {\r\n  /* 총 너비 */\r\n  width: 980px;\r\n}\r\n.box_group .box1 {\r\n  /* 총 너비의 약 8.3% */\r\n  width: 81.66667px;\r\n}\r\n.box_group .box2 {\r\n  /* 총 너비의 약 66.7% */\r\n  width: 653.33333px;\r\n}\r\n.box_group .box3 {\r\n  /* 총 너비의 25% */\r\n  width: 245px;\r\n}\r\n\r\n```\r\n\r\n위와 같이 함수는 `@include` 같은 별도의 지시어 없이 사용하기 때문에 내가 지정한 함수와 내장 함수(Built-in Functions)의 이름이 충돌할 수 있습니다.  \r\n따라서 내가 지정한 함수에는 별도의 접두어를 붙여주는 것이 좋습니다.\r\n\r\n> 내장 함수란, 응용 프로그램에 내장되어 있으며 최종 사용자가 액세스 할 수 있는 기능입니다.  \r\n> 예를 들어, 대부분의 스프레드 시트 응용 프로그램은 행이나 열의 모든 셀을 추가하는 내장 SUM 함수를 지원합니다.\r\n\r\n예를 들어, 색의 빨강 성분을 가져오는 내장 함수로 이미 `red()`가 있습니다.  \r\n같은 이름을 사용하여 함수를 정의하면 이름이 충돌하기 때문에 별도의 접두어를 붙여 `extract-red()` 같은 이름을 만들 수 있습니다.\r\n\r\n```\r\n// 내가 정의한 함수\r\n@function extract-red($color) {\r\n  // 내장 함수\r\n  @return rgb(red($color), 0, 0);\r\n}\r\n\r\ndiv {\r\n  color: extract-red(#D55A93);\r\n}\r\n\r\n```\r\n\r\n혹은 모든 내장 함수의 이름을 다 알고 있을 수 없기 때문에 특별한 이름을 접두어로 사용할 수도 있습니다.  \r\n`my-custom-func-red()`\r\n\r\n## 조건과 반복(Control Directives / Expressions)\r\n\r\n### if (함수)\r\n\r\n조건의 값(`true`, `false`)에 따라 두 개의 표현식 중 하나만 반환합니다.  \r\n[조건부 삼항 연산자(conditional ternary operator)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)와 비슷합니다.\r\n\r\n조건의 값이 `true`이면 `표현식1`을,  \r\n조건의 값이 `false`이면 `표현식2`를 실행합니다.\r\n\r\n```\r\nif(조건, 표현식1, 표현식2)\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$width: 555px;\r\ndiv {\r\n  width: if($width > 300px, $width, null);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 555px;\r\n}\r\n\r\n```\r\n\r\n### @if (지시어)\r\n\r\n`@if` 지시어는 조건에 따른 분기 처리가 가능하며, [if 문(if statements)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/if...else)과 유사합니다.  \r\n같이 사용할 수 있는 지시어는 `@else`, `if`가 있습니다.  \r\n추가 지시어를 사용하면 좀 더 복잡한 조건문을 작성할 수 있습니다.\r\n\r\n```\r\n// @if\r\n@if (조건) {\r\n  /* 조건이 참일 때 구문 */\r\n}\r\n\r\n// @if @else\r\n@if (조건) {\r\n  /* 조건이 참일 때 구문 */\r\n} @else {\r\n  /* 조건이 거짓일 때 구문 */\r\n}\r\n\r\n// @if @else if\r\n@if (조건1) {\r\n  /* 조건1이 참일 때 구문 */\r\n} @else if (조건2) {\r\n  /* 조건2가 참일 때 구문 */\r\n} @else {\r\n  /* 모두 거짓일 때 구문 */\r\n}\r\n\r\n```\r\n\r\n조건에 `()`는 생략이 가능하기 때문에, `()` 없이 작성하는 방법이 좀 더 편리할 수 있습니다.\r\n\r\n```\r\n$bg: true;\r\ndiv {\r\n  @if $bg {\r\n    background: url(\"/images/a.jpg\");\r\n  }\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$color: orange;\r\ndiv {\r\n  @if $color == strawberry {\r\n    color: #FE2E2E;\r\n  } @else if $color == orange {\r\n    color: #FE9A2E;\r\n  } @else if $color == banana {\r\n    color: #FFFF00;\r\n  } @else {\r\n    color: #2A1B0A;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: #FE9A2E;\r\n}\r\n\r\n```\r\n\r\n조건에는 논리 연산자 `and`, `or`, `not`을 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n@function limitSize($size) {\r\n  @if $size >= 0 and $size <= 200px {\r\n    @return 200px;\r\n  } @else {\r\n    @return 800px;\r\n  }\r\n}\r\n\r\ndiv {\r\n  width: limitSize(180px);\r\n  height: limitSize(340px);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 200px;\r\n  height: 800px;\r\n}\r\n\r\n```\r\n\r\n좀 더 복잡하지만 실용적인 예제를 봅시다.  \r\nSass의 내장 함수 `unitless()`는 숫자에 단위가 있는지 여부를 반환합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin pCenter($w, $h, $p: absolute) {\r\n  @if\r\n    $p == absolute\r\n    or $p == fixed\r\n    or not $p == relative\r\n    or not $p == static\r\n  {\r\n    width: if(unitless($w), #{$w}px, $w);\r\n    height: if(unitless($h), #{$h}px, $h);\r\n    position: $p;\r\n    top: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    margin: auto;\r\n  }\r\n}\r\n\r\n.box1 {\r\n  @include pCenter(10px, 20px);\r\n}\r\n.box2 {\r\n  @include pCenter(50, 50, fixed);\r\n}\r\n.box3 {\r\n  @include pCenter(100, 200, relative);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  width: 10px;\r\n  height: 20px;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  margin: auto;\r\n}\r\n\r\n.box2 {\r\n  width: 50px;\r\n  height: 50px;\r\n  position: fixed;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  margin: auto;\r\n}\r\n\r\n```\r\n\r\n### @for\r\n\r\n`@for`는 스타일을 반복적으로 출력합니다.  \r\n[for 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for)과 유사합니다.\r\n\r\n`@for`는 `through`를 사용하는 형식과 `to`를 사용하는 형식으로 나뉩니다.  \r\n두 형식은 종료 조건이 해석되는 방식이 다릅니다.\r\n\r\n```\r\n// through\r\n// 종료 만큼 반복\r\n@for $변수 from 시작 through 종료 {\r\n  // 반복 내용\r\n}\r\n\r\n// to\r\n// 종료 직전까지 반복\r\n@for $변수 from 시작 to 종료 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n차이점을 이해하기 위해 다음 예제를 살펴봅시다.  \r\n변수는 관례상 `$i`를 사용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n// 1부터 3번 반복\r\n@for $i from 1 through 3 {\r\n  .through:nth-child(#{$i}) {\r\n    width : 20px * $i\r\n  }\r\n}\r\n\r\n// 1부터 3 직전까지만 반복(2번 반복)\r\n@for $i from 1 to 3 {\r\n  .to:nth-child(#{$i}) {\r\n    width : 20px * $i\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.through:nth-child(1) { width: 20px; }\r\n.through:nth-child(2) { width: 40px; }\r\n.through:nth-child(3) { width: 60px; }\r\n\r\n.to:nth-child(1) { width: 20px; }\r\n.to:nth-child(2) { width: 40px; }\r\n\r\n```\r\n\r\n`to`는 주어진 값 직전까지만 반복해야할 경우 유용할 수 있습니다.  \r\n그러나 `:nth-child()`에서 특히 유용하게 사용되는 `@for`는 일반적으로 `through`를 사용하길 권장합니다.\r\n\r\n### @each\r\n\r\n`@each`는 List와 Map 데이터를 반복할 때 사용합니다.  \r\n[for in 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...in)과 유사합니다.\r\n\r\n```\r\n@each $변수 in 데이터 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\nList 데이터를 반복해 보겠습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n// List Data\r\n$fruits: (apple, orange, banana, mango);\r\n\r\n.fruits {\r\n  @each $fruit in $fruits {\r\n    li.#{$fruit} {\r\n      background: url(\"/images/#{$fruit}.png\");\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fruits li.apple {\r\n  background: url(\"/images/apple.png\");\r\n}\r\n.fruits li.orange {\r\n  background: url(\"/images/orange.png\");\r\n}\r\n.fruits li.banana {\r\n  background: url(\"/images/banana.png\");\r\n}\r\n.fruits li.mango {\r\n  background: url(\"/images/mango.png\");\r\n}\r\n\r\n```\r\n\r\n혹시 매번 반복마다 Index 값이 필요하다면 다음과 같이 `index()` 내장 함수를 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$fruits: (apple, orange, banana, mango);\r\n\r\n.fruits {\r\n  @each $fruit in $fruits {\r\n    $i: index($fruits, $fruit);\r\n    li:nth-child(#{$i}) {\r\n      left: 50px * $i;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fruits li:nth-child(1) {\r\n  left: 50px;\r\n}\r\n.fruits li:nth-child(2) {\r\n  left: 100px;\r\n}\r\n.fruits li:nth-child(3) {\r\n  left: 150px;\r\n}\r\n.fruits li:nth-child(4) {\r\n  left: 200px;\r\n}\r\n\r\n```\r\n\r\n동시에 여러 개의 List 데이터를 반복 처리할 수도 있습니다.  \r\n단, 각 데이터의 Length가 같아야 합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$apple: (apple, korea);\r\n$orange: (orange, china);\r\n$banana: (banana, japan);\r\n\r\n@each $fruit, $country in $apple, $orange, $banana {\r\n  .box-#{$fruit} {\r\n    background: url(\"/images/#{$country}.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box-apple {\r\n  background: url(\"/images/korea.png\");\r\n}\r\n.box-orange {\r\n  background: url(\"/images/china.png\");\r\n}\r\n.box-banana {\r\n  background: url(\"/images/japan.png\");\r\n}\r\n\r\n```\r\n\r\nMap 데이터를 반복할 경우 하나의 데이터에 두 개의 변수가 필요합니다.\r\n\r\n```\r\n@each $key변수, $value변수 in 데이터 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n```\r\n$fruits-data: (\r\n  apple: korea,\r\n  orange: china,\r\n  banana: japan\r\n);\r\n\r\n@each $fruit, $country in $fruits-data {\r\n  .box-#{$fruit} {\r\n    background: url(\"/images/#{$country}.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n```\r\n.box-apple {\r\n  background: url(\"/images/korea.png\");\r\n}\r\n.box-orange {\r\n  background: url(\"/images/china.png\");\r\n}\r\n.box-banana {\r\n  background: url(\"/images/japan.png\");\r\n}\r\n\r\n```\r\n\r\n### @while\r\n\r\n`@while`은 조건이 `false`로 평가될 때까지 내용을 반복합니다.  \r\n[while 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/while)과 유사하게 잘못된 조건으로 인해 컴파일 중 무한 루프에 빠질 수 있습니다.  \r\n사용을 권장하지 않습니다.\r\n\r\n```\r\n@while 조건 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n```\r\n$i: 6;\r\n\r\n@while $i > 0 {\r\n  .item-#{$i} {\r\n    width: 2px * $i;\r\n  }\r\n  $i: $i - 2;\r\n}\r\n\r\n```\r\n\r\n```\r\n.item-6 { width: 12px; }\r\n.item-4 { width: 8px; }\r\n.item-2 { width: 4px; }\r\n\r\n```\r\n\r\n## 내장 함수(Built-in Functions)\r\n\r\nSass에서 기본적으로 제공하는 내장 함수에는 많은 종류가 있습니다.  \r\n모두 소개하지 않고, 주관적 경험에 의거해 필요하거나 필요할 수 있는 함수만 정리했습니다.\r\n\r\n[Sass Built-in Functions](http://sass-lang.com/documentation/Sass/Script/Functions.html)에서 모든 내장 함수를 확인할 수 있습니다.\r\n\r\n-   `[]`는 선택 가능한 인수(argument)입니다.\r\n-   [Zero-based numbering](https://en.wikipedia.org/wiki/Zero-based_numbering)을 사용하지 않습니다.\r\n\r\n### 색상(RGB / HSL / Opacity) 함수\r\n\r\n[mix($color1, $color2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method) : 두 개의 색을 섞습니다.\r\n\r\n[lighten($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#lighten-instance_method) : 더 밝은색을 만듭니다.\r\n\r\n[darken($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#darken-instance_method) : 더 어두운색을 만듭니다.\r\n\r\n[saturate($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#saturate-instance_method) : 색상의 채도를 올립니다.\r\n\r\n[desaturate($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#desaturate-instance_method) : 색상의 채도를 낮춥니다.\r\n\r\n[grayscale($color)](http://sass-lang.com/documentation/Sass/Script/Functions.html#grayscale-instance_method) : 색상을 회색으로 변환합니다.\r\n\r\n[invert($color)](http://sass-lang.com/documentation/Sass/Script/Functions.html#invert-instance_method) : 색상을 반전시킵니다.\r\n\r\n[rgba($color, $alpha)](http://sass-lang.com/documentation/Sass/Script/Functions.html#rgba-instance_method) : 색상의 투명도를 변경합니다.\r\n\r\n[opacify($color, $amount) / fade-in($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#opacify-instance_method) : 색상을 더 불투명하게 만듭니다.\r\n\r\n[transparentize($color, $amount) / fade-out($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#transparentize-instance_method) : 색상을 더 투명하게 만듭니다.\r\n\r\n### 문자(String) 함수\r\n\r\n[unquote($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unquote-instance_method) : 문자에서 따옴표를 제거합니다.\r\n\r\n[quote($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#quote-instance_method) : 문자에 따옴표를 추가합니다.\r\n\r\n[str-insert($string, $insert, $index)](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_insert-instance_method) : 문자의 index번째에 특정 문자를 삽입합니다.\r\n\r\n[str-index($string, $substring)](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_index-instance_method) : 문자에서 특정 문자의 첫 index를 반환합니다.\r\n\r\n[str-slice($string, $start-at, \\[$end-at\\])](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_slice-instance_method) : 문자에서 특정 문자(몇 번째 글자부터 몇 번째 글자까지)를 추출합니다.\r\n\r\n[to-upper-case($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#to_upper_case-instance_method) : 문자를 대문자를 변환합니다.\r\n\r\n[to-lower-case($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#to_lower_case-instance_method) : 문자를 소문자로 변환합니다.\r\n\r\n### 숫자(Number) 함수\r\n\r\n[percentage($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#percentage-instance_method) : 숫자(단위 무시)를 백분율로 변환합니다.\r\n\r\n[round($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#round-instance_method) : 정수로 반올림합니다.\r\n\r\n[ceil($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#ceil-instance_method) : 정수로 올림합니다.\r\n\r\n[floor($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#floor-instance_method) : 정수로 내림(버림)합니다.\r\n\r\n[abs($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#abs-instance_method) : 숫자의 절대 값을 반환합니다.\r\n\r\n[min($numbers…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#min-instance_method) : 숫자 중 최소 값을 찾습니다.\r\n\r\n[max($numbers…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#max-instance_method) : 숫자 중 최대 값을 찾습니다.\r\n\r\n[random()](http://sass-lang.com/documentation/Sass/Script/Functions.html#random-instance_method) : `0` 부터 `1` 사이의 난수를 반환합니다.\r\n\r\n### List 함수\r\n\r\n모든 List 내장 함수는 기존 List 데이터를 갱신하지 않고 새 List 데이터를 반환합니다.  \r\n모든 List 내장 함수는 Map 데이터에서도 사용할 수 있습니다.\r\n\r\n[length($list)](http://sass-lang.com/documentation/Sass/Script/Functions.html#length-instance_method) : List의 개수를 반환합니다.\r\n\r\n[nth($list, $n)](http://sass-lang.com/documentation/Sass/Script/Functions.html#nth-instance_method) : List에서 n번째 값을 반환합니다.\r\n\r\n[set-nth($list, $n, $value)](http://sass-lang.com/documentation/Sass/Script/Functions.html#set_nth-instance_method) : List에서 n번째 값을 다른 값으로 변경합니다.\r\n\r\n[join($list1, $list2, \\[$separator\\])](http://sass-lang.com/documentation/Sass/Script/Functions.html#join-instance_method) : 두 개의 List를 하나로 결합합니다.\r\n\r\n[zip($lists…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#zip-instance_method) : 여러 List들을 하나의 다차원 List로 결합합니다.\r\n\r\n[index($list, $value)](http://sass-lang.com/documentation/Sass/Script/Functions.html#index-instance_method) : List에서 특정 값의 index를 반환합니다.\r\n\r\n### Map 함수\r\n\r\n모든 Map 내장 함수는 기존 Map 데이터를 갱신하지 않고 새 Map 데이터를 반환합니다.\r\n\r\n[map-get($map, $key)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_get-instance_method) : Map에서 특정 key의 value를 반환합니다.\r\n\r\n[map-merge($map1, $map2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_merge-instance_method) : 두 개의 Map을 병합하여 새로운 Map를 만듭니다.\r\n\r\n[map-keys($map)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_keys-instance_method) : Map에서 모든 key를 List로 반환합니다.\r\n\r\n[map-values($map)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_values-instance_method) : Map에서 모든 value를 List로 반환합니다.\r\n\r\n### 관리(Introspection) 함수\r\n\r\n[variable-exists(name)](http://sass-lang.com/documentation/Sass/Script/Functions.html#variable_exists-instance_method) : 변수가 현재 범위에 존재하는지 여부를 반환합니다.(인수는 `$`없이 변수의 이름만 사용합니다.)\r\n\r\n[unit($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unit-instance_method) : 숫자의 단위를 반환합니다.\r\n\r\n[unitless($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unitless-instance_method) : 숫자에 단위가 있는지 여부를 반환합니다.\r\n\r\n[comparable($number1, $number2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#comparable-instance_method) : 두 개의 숫자가 연산 가능한지 여부를 반환합니다.\r\n\r\n# 참고 자료(References)\r\n\r\n[http://sass-lang.com/documentation](http://sass-lang.com/documentation)  \r\n[https://www.sitepoint.com/sass-basics-operators/](https://www.sitepoint.com/sass-basics-operators/)  \r\n[https://sass-guidelin.es/ko/](https://sass-guidelin.es/ko/)  \r\n[http://www.thesassway.com/](http://www.thesassway.com/)","memberId":1,"boardId":3,"regDate":"2020-12-20 01:25:13","updateDate":"2021-01-15 20:54:38","extra_writer":"D.K","extra_boardName":"html&CSS","extra_boardCode":"html&CSS","rcmCount":2,"hit":2,"commentsCount":4}],"Sass":[{"id":1,"title":"SCSS(Sacc)정리?????","body":"CSS는 상대적으로 배우기 쉽고 재미있습니다.  \r\n웹 개발 초심자에게는 이만큼 접근하기 좋은 게 없죠.\r\n\r\nCSS는 분명 쉽고 재밌지만, 작업이 고도화될수록 불편함도 같이 커집니다.  \r\n불필요한 선택자(Selector)의 과용과 연산 기능의 한계, 구문(Statement)의 부재 등 프로젝트의 규모가 커질수록 아쉬움도 같이 커지죠.  \r\n하지만 웹에서는 표준 CSS만 동작할 수 있기 때문에 다른 선택권이 없습니다.\r\n\r\n그렇다면 우리는 앞으로 계속 CSS만 사용해야 할까요?\r\n\r\n# CSS Preprocessor 란?\r\n\r\nHTML, CSS를 다루는 분이라면 한 번은 들어봤을 Sass, Less 등이 있습니다.  \r\n이 친구들은 CSS 전(예비)처리기 입니다.  \r\n보통 CSS Preprocessor 라고 부릅니다.\r\n\r\nCSS가 동작하기 전에 사용하는 기능으로,  \r\n웹에서는 분명 CSS가 동작하지만 우리는 CSS의 불편함을 이런 확장 기능으로 상쇄할 수 있습니다.\r\n\r\n> 사스는 기초 언어에 힘과 우아함을 더해주는 CSS의 확장이다.\r\n\r\n### 어떻게 사용하나요?\r\n\r\n위에서 언급한 것처럼 웹에서는 CSS만 동작합니다.  \r\n[Sass](https://sass-lang.com/), [Less](http://lesscss.org/), [Stylus](http://stylus-lang.com/) 같은 전처리기(이하 ‘전처리기’로 표기)는 직접 동작시킬 수 없습니다.  \r\n그렇다면 어떻게 사용할 수 있을까요?\r\n\r\nCSS는 불편하니 일단 배제하고 우선 전처리기로 작성(코딩)합니다.  \r\n전처리기는 CSS 문법과 굉장히 유사하지만 선택자의 중첩(Nesting)이나 조건문, 반복문, 다양한 단위(Unit)의 연산 등… 표준 CSS 보다 훨씬 많은 기능을 사용해서 편리하게 작성할 수 있습니다.  \r\n단, 웹에서는 직접 동작하지 않으니 이렇게 작성한 전처리기를 웹에서 동작 가능한 표준의 CSS로 컴파일(Compile)합니다.  \r\n전처리기로 작성하고 CSS로 컴파일해서 동작시키는 거죠.\r\n\r\n### 컴파일은 어떻게 하나요?\r\n\r\n전처리기 종류마다 방법이 조금씩 다르고 여러 방식을 제공합니다.  \r\n보통의 경우 컴파일러(Compiler)가 필요합니다.  \r\n우리는 이제 Sass(SCSS)를 알아볼 것이고 컴파일 방법에 대해서도 같이 살펴보겠습니다.\r\n\r\n### 왜 Sass(SCSS)죠?\r\n\r\n보통 언급되는 전처리기 3대장으로 Less, Sass(SCSS), Stylus가 있습니다.\r\n\r\n저는 가장 많이 사용하고 진입장벽이 비교적 낮았던 Less를 처음 사용했습니다.  \r\n기본적인 기능은 전처리기들이 다 비슷합니다만 개인적으로 Less는 몇몇 기능에 큰 아쉬움이 있었습니다.  \r\n정확하게 언급하진 않겠지만 프로젝트 진행 중 Less에서 제공하는 기능의 한계로 막히는 경우가 몇 번 있었는데 그 기능이 Sass나 Stylus에는 있었습니다.  \r\n하지만 진입장벽이 낮기 때문에 접하기 쉽고 그만큼 많이 사용되는 듯합니다.\r\n\r\nStylus 같은 경우는 현재 이 블로그(HEROPY)를 만들면서 사용하고 있습니다.  \r\n깔끔하고 좀 더 세련됐으며 기능도 훌륭합니다.  \r\n하지만 덜 사용되며(덜 유명하며) 비교적 늦게 나왔기 때문에 성숙도는 떨어집니다.  \r\n그 때문인지 컴파일 후 사소한 버그가 몇몇 보입니다.\r\n\r\nSass(SCSS)는 언급한 두 가지 전처리기의 장점을 모두 가집니다.  \r\n문법은 Sass가 Stylus와 비슷하고, SCSS는 Less와 비슷하며, Sass와 SCSS는 하나의 컴파일러로 모두 컴파일 가능합니다.  \r\n또한, 2006년부터 시작하여 가장 오래된 CSS 확장 언어이며 그만큼 높은 성숙도와 많은 커뮤니티를 가지고 있고 기능도 훌륭합니다.  \r\n그래서 저는 Sass(SCSS)를 선택했습니다.\r\n\r\n### Sass와 SCSS는 차이점은 뭔가요?\r\n\r\nSass(Syntactically Awesome Style Sheets)의 3버전에서 새롭게 등장한 SCSS는 CSS 구문과 완전히 호환되도록 새로운 구문을 도입해 만든 Sass의 모든 기능을 지원하는 CSS의 상위집합(Superset) 입니다.  \r\n즉, SCSS는 CSS와 거의 같은 문법으로 Sass 기능을 지원한다는 말입니다.\r\n\r\n더 쉽고 간단한 차이는 `{}`(중괄호)와 `;`(세미콜론)의 유무입니다.  \r\n아래의 예제를 비교해 보세요.\r\n\r\nSass:\r\n\r\n```sass\r\n.list\r\n  width: 100px\r\n  float: left\r\n  li\r\n    color: red\r\n    background: url(\"./image.jpg\")\r\n    &:last-child\r\n      margin-right: -10px\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```scss\r\n.list {\r\n  width: 100px;\r\n  float: left;\r\n  li {\r\n    color: red;\r\n    background: url(\"./image.jpg\");\r\n    &:last-child {\r\n      margin-right: -10px;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nSass는 선택자의 유효범위를 ‘들여쓰기’로 구분하고, SCSS는 `{}`로 범위를 구분합니다.  \r\nSass 방식과 SCSS 방식 중 어떤 방식이 마음에 드세요?\r\n\r\n거의 유일합니다만, 다른 차이도 있습니다.  \r\n아래는 Mixins(‘믹스인’은 재사용 가능한 기능을 만드는 방식의 의미합니다) 예제입니다.  \r\nSass는 단축 구문으로 사용합니다.\r\n\r\n:Sass\r\n\r\n```sass\r\n=border-radius($radius)\r\n  -webkit-border-radius: $radius\r\n  -moz-border-radius:    $radius\r\n  -ms-border-radius:     $radius\r\n  border-radius:         $radius\r\n\r\n.box\r\n  +border-radius(10px)\r\n\r\n```\r\n\r\n:SCSS\r\n\r\n```scss\r\n@mixin border-radius($radius) {\r\n  -webkit-border-radius: $radius;\r\n     -moz-border-radius: $radius;\r\n      -ms-border-radius: $radius;\r\n          border-radius: $radius;\r\n}\r\n\r\n.box { @include border-radius(10px); }\r\n\r\n```\r\n\r\nSass는 `=`와 `+` 기호로 Mixins 기능을 사용했고,  \r\nSCSS는 `@mixin`과 `@include`로 기능을 사용했습니다.\r\n\r\n단순한 몇 가지를 제외하면 거의 차이가 없지만 복잡한 문장이 될 경우 여러 환경에 따른 장단점이 있을 수 있습니다.  \r\nSass는 좀 더 간결하고 작성하기 편리하며, `{}`나 `;`를 사용하지 않아도 되니 코드가 훨씬 깔끔해집니다.  \r\nSCSS는 인라인 코드(한 줄 작성)를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽습니다.\r\n\r\n이렇게 몇몇 장단점이 있기 때문에 회사나 팀에서 원하는 방식을 사용해야 하거나, 개인 취향에 따라서 선택할 수 있습니다.  \r\n단지 상황에 맞는, 원하는 방식으로 골라서 사용하면 됩니다.\r\n\r\n보통의 경우 SCSS를 추천합니다.\r\n\r\n# 컴파일 방법\r\n\r\nSass(SCSS)는 웹에서 직접 동작할 수 없습니다.  \r\n어디까지나 최종에는 표준 CSS로 동작해야 하며, 우리는 전처리기로 작성 후 CSS로 컴파일해야 합니다.  \r\n다양한 방법으로 컴파일이 가능하지만 자바스크립트 개발 환경([Node.js](https://nodejs.org/ko/))에서 추천하는 몇가지 방법을 소개합니다.\r\n\r\n### SassMeister\r\n\r\n간단한 Sass 코드는 컴파일러를 설치하는게 부담될 수 있습니다.  \r\n그럴 경우 [SassMeister](https://www.sassmeister.com/)를 사용할 수 있습니다.\r\n\r\n페이지 접속 후 바로 Sass나 SCSS 문법으로 코딩하면 CSS로 실시간 변환됩니다.  \r\nHTML를 작성하여 적용된 결과를 보거나 Sass 버전 설정 등 여러 환경 설정들을 지원하니 학습에 도움이 될 것입니다.\r\n\r\n### node-sass\r\n\r\n[node-sass](https://github.com/sass/node-sass)는 Node.js를 컴파일러인 [LibSass](https://sass-lang.com/libsass)에 바인딩한 라이브러리 입니다.  \r\nNPM으로 전역 설치하여 사용합니다.\r\n\r\n```sass\r\n$ npm install -g node-sass\r\n\r\n```\r\n\r\n컴파일하려는 파일의 경로와 컴파일된 파일이 저장될 경로를 설정합니다.  \r\n`[]`는 선택사항입니다.\r\n\r\n```sass\r\n$ node-sass [옵션] <입력파일경로> [출력파일경로]\r\n\r\n```\r\n\r\n```sass\r\n$ node-sass scss/main.scss public/main.css\r\n\r\n```\r\n\r\n여러 출력 경로를 설정할 수 있습니다.\r\n\r\n```sass\r\n$ node-sass scss/main.scss public/main.css dist/style.css\r\n\r\n```sass\r\n\r\n옵션을 적용할 수도 있습니다.  \r\n옵션으로 `--watch` 혹은 `-w`를 입력하면, 런타임 중 파일을 감시하여 저장 시 자동으로 변경 사항을 컴파일합니다.\r\n\r\n```sass\r\n$ node-sass --watch scss/main.scss public/main.css\r\n\r\n```\r\n\r\n기타 옵션은 [node-sass CLI](https://github.com/sass/node-sass#command-line-interface)에서 확인할 수 있습니다.\r\n\r\n### Gulp\r\n\r\n빌드 자동화 도구(JavaScript Task Runner)인 [Gulp](https://gulpjs.com/)에서는 `gulpfile.js`을 만들어 아래와 같이 설정할 수 있습니다.  \r\n먼저 `gulp` 명령을 사용하기 위해서는 전역 설치가 필요합니다.\r\n\r\n```sass\r\n$ npm install -g gulp\r\n\r\n```\r\n\r\nGulp와 함께 Sass 컴파일러인 [gulp-sass](https://github.com/dlmanning/gulp-sass)를 개발 의존성(devDependency) 모드로 설치합니다.  \r\ngulp-sass는 위에서 살펴본 node-sass를 Gulp에서 사용할 수 있도록 만들어진 플러그인입니다.\r\n\r\n```sass\r\n$ npm install --save-dev gulp gulp-sass\r\n\r\n```\r\n\r\n```java\r\n// gulpfile.js\r\nvar gulp = require('gulp')\r\nvar sass = require('gulp-sass')\r\n\r\n// 일반 컴파일\r\ngulp.task('sass', function () {\r\n  return gulp.src('./src/scss/*.scss')  // 입력 경로\r\n    .pipe(sass().on('error', sass.logError))\r\n    .pipe(gulp.dest('./dist/css'));  // 출력 경로\r\n});\r\n\r\n// 런타임 중 파일 감시\r\ngulp.task('sass:watch', function () {\r\n  gulp.watch('./src/scss/*.scss', ['sass']);  // 입력 경로와 파일 변경 감지 시 실행할 Actions(Task Name)\r\n});\r\n\r\n```\r\n\r\n환경을 설정했으니 컴파일합니다.\r\n\r\n```java\r\n$ gulp sass\r\n\r\n```\r\n\r\n런타임 중 파일 감시 모드로 실행할 수도 있습니다.\r\n\r\n```java\r\n$ gulp sass:watch\r\n\r\n```\r\n\r\n### Webpack\r\n\r\nJavaScript 모듈화 도구인 [Webpack](https://webpack.js.org/)의 설정은 좀 더 복잡합니다.  \r\n[Webpack - 1 - 시작하기 / EJS / SASS(SCSS)](https://heropy.blog/2017/10/18/webpack_1_start_ejs_sass/) 포스트를 참고하세요.\r\n\r\n### Parcel\r\n\r\n웹 애플리케이션 번들러 [Parcel](https://parceljs.org/)은 굉장히 단순하게 컴파일할 수 있습니다.  \r\n좀 더 자세한 내용은 [Parcel - 시작하기 / SASS / PostCSS / Babel / Production](https://heropy.blog/2018/01/20/parcel-1-start/)을 참고하세요.\r\n\r\n우선 Parcel를 전역으로 설치합니다.\r\n\r\n```java\r\n$ npm install -g parcel-bundler\r\n\r\n```\r\n\r\n프로젝트에 Sass 컴파일러(node-sass)를 설치합니다.\r\n\r\n```java\r\n$ npm install --save-dev node-sass\r\n\r\n```\r\n\r\n이제 HTML에 `<link>`로 Sass 파일만 연결하면 됩니다.  \r\n다른 설정은 필요하지 않습니다.\r\n\r\n```java\r\n<link rel=\"stylesheet\" href=\"scss/main.scss\">\r\n\r\n```\r\n\r\n```java\r\n$ parcel index.html\r\n# 혹은\r\n$ parcel build index.html\r\n\r\n```\r\n\r\n`dist/`에서 컴파일된 Sass 파일을 볼 수 있고,  \r\n별도의 포트 번호를 설정하지 않았다면 `[http://localhost:1234](http://localhost:1234)`에 접속하여 적용 상태를 확인할 수 있습니다.\r\n\r\n# 문법(Syntax)\r\n\r\n위의 ‘Sass와 SCSS의 차이점’에서 설명한대로 Sass와 SCSS의 기능은 동일하니, 편의를 위해 SCSS 문법으로 설명을 진행합니다.  \r\n단, Sass와 SCSS의 차이점이 있다면 나눠 설명합니다.\r\n\r\n## 주석(Comment)\r\n\r\nCSS 주석은 `/* ... */` 입니다.  \r\nSass(SCSS)는 JavaScript처럼 두 가지 스타일의 주석을 사용합니다.\r\n\r\n```css\r\n// 컴파일되지 않는 주석\r\n/* 컴파일되는 주석 */\r\n\r\n```\r\n\r\nSass의 경우 컴파일되는 여러 줄 주석을 사용할 때 각 줄 앞에 `*`을 붙여야 하고, 중요한 것은 `*`의 라인을 맞춰줘야 합니다.\r\n\r\nSass:\r\n\r\n```css\r\n/* 컴파일되는\r\n * 여러 줄\r\n * 주석 */\r\n\r\n// Error\r\n/* 컴파일되는\r\n* 여러 줄\r\n    * 주석 */\r\n\r\n```\r\n\r\nSCSS는 각 줄에 `*`이 없어도 문제되지 않습니다. 따라서 기존 CSS와 호환이 쉽습니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n/*\r\n컴파일되는\r\n여러 줄\r\n주석\r\n*/\r\n\r\n```\r\n\r\n## 데이터 종류(Data Types)\r\n\r\n| 데이터 | 설명 | 예시 |\r\n| --- | --- | --- |\r\n| Numbers | 숫자 | `1`, `.82`, `20px`, `2em`… |\r\n| Strings | 문자 | `bold`, `relative`, `\"/images/a.png\"`, `\"dotum\"` |\r\n| Colors | 색상 표현 | `red`, `blue`, `#FFFF00`, `rgba(255,0,0,.5)` |\r\n| Booleans | 논리 | `true`, `false` |\r\n| Nulls | 아무것도 없음 | `null` |\r\n| Lists | 공백이나 `,`로 구분된 값의 목록 | `(apple, orange, banana)`, `apple orange` |\r\n| Maps | Lists와 유사하나 값이 `Key: Value` 형태 | `(apple: a, orange: o, banana: b)` |\r\n\r\n### 특이사항\r\n\r\nSass에서 사용하는 데이터 종류들의 몇 가지 특이사항을 소개합니다.\r\n\r\n-   Numbers: 숫자에 단위가 있거나 없습니다.\r\n-   Strings: 문자에 따옴표가 있거나 없습니다.\r\n-   Nulls: 속성값으로 `null`이 사용되면 컴파일하지 않습니다.\r\n-   Lists: `()`를 붙이거나 붙이지 않습니다.\r\n-   Maps: `()`를 꼭 붙여야 합니다.\r\n\r\n## 중첩(Nesting)\r\n\r\nSass는 중첩 기능을 사용할 수 있습니다.  \r\n상위 선택자의 반복을 피하고 좀 더 편리하게 복잡한 구조를 작성할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n.section {\r\n  width: 100%;\r\n  .list {\r\n    padding: 20px;\r\n    li {\r\n      float: left;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```css\r\n.section {\r\n  width: 100%;\r\n}\r\n.section .list {\r\n  padding: 20px;\r\n}\r\n.section .list li {\r\n  float: left;\r\n}\r\n\r\n```\r\n\r\n### Ampersand (상위 선택자 참조)\r\n\r\n중첩 안에서 `&` 키워드는 상위(부모) 선택자를 참조하여 치환합니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n.btn {\r\n  position: absolute;\r\n  &.active {\r\n    color: red;\r\n  }\r\n}\r\n\r\n.list {\r\n  li {\r\n    &:last-child {\r\n      margin-right: 0;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.btn {\r\n  position: absolute;\r\n}\r\n.btn.active {\r\n  color: red;\r\n}\r\n.list li:last-child {\r\n  margin-right: 0;\r\n}\r\n\r\n```\r\n\r\n`&` 키워드가 참조한 상위 선택자로 치환되는 것이기 때문에 다음과 같이 응용할 수도 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.fs {\r\n  &-small { font-size: 12px; }\r\n  &-medium { font-size: 14px; }\r\n  &-large { font-size: 16px; }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fs-small {\r\n  font-size: 12px;\r\n}\r\n.fs-medium {\r\n  font-size: 14px;\r\n}\r\n.fs-large {\r\n  font-size: 16px;\r\n}\r\n\r\n```\r\n\r\n### @at-root (중첩 벗어나기)\r\n\r\n중첩에서 벗어나고 싶을 때 `@at-root` 키워드를 사용합니다.  \r\n중첩 안에서 생성하되 중첩 밖에서 사용해야 경우에 유용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.list {\r\n  $w: 100px;\r\n  $h: 50px;\r\n  li {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n  @at-root .box {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.list li {\r\n  width: 100px;\r\n  height: 50px;\r\n}\r\n.box {\r\n  width: 100px;\r\n  height: 50px;\r\n}\r\n\r\n```\r\n\r\n아래 예제 처럼 `.list` 안에 있는 특정 변수를 범위 밖에서 사용할 수 없기 때문에, 위 예제 처럼 `@at-root` 키워드를 사용해야 합니다.(변수는 아래에서 설명합니다)\r\n\r\n```\r\n.list {\r\n  $w: 100px;\r\n  $h: 50px;\r\n  li {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n}\r\n\r\n// Error\r\n.box {\r\n  width: $w;\r\n  height: $h;\r\n}\r\n\r\n```\r\n\r\n### 중첩된 속성\r\n\r\n`font-`, `margin-` 등과 같이 동일한 네임 스페이스를 가지는 속성들을 다음과 같이 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.box {\r\n  font: {\r\n    weight: bold;\r\n    size: 10px;\r\n    family: sans-serif;\r\n  };\r\n  margin: {\r\n    top: 10px;\r\n    left: 20px;\r\n  };\r\n  padding: {\r\n    bottom: 40px;\r\n    right: 30px;\r\n  };\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  font-weight: bold;\r\n  font-size: 10px;\r\n  font-family: sans-serif;\r\n  margin-top: 10px;\r\n  margin-left: 20px;\r\n  padding-bottom: 40px;\r\n  padding-right: 30px;\r\n}\r\n\r\n```\r\n\r\n## 변수(Variables)\r\n\r\n반복적으로 사용되는 값을 변수로 지정할 수 있습니다.  \r\n변수 이름 앞에는 항상 `$`를 붙입니다.\r\n\r\n```\r\n$변수이름: 속성값;\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$color-primary: #e96900;\r\n$url-images: \"/assets/images/\";\r\n$w: 200px;\r\n\r\n.box {\r\n  width: $w;\r\n  margin-left: $w;\r\n  background: $color-primary url($url-images + \"bg.jpg\");\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  width: 200px;\r\n  margin-left: 200px;\r\n  background: #e96900 url(\"/assets/images/bg.jpg\");\r\n}\r\n\r\n```\r\n\r\n### 변수 유효범위(Variable Scope)\r\n\r\n변수는 사용 가능한 유효범위가 있습니다.  \r\n선언된 블록(`{}`) 내에서만 유효범위를 가집니다.\r\n\r\n변수 `$color`는 `.box1`의 블록 안에서 설정되었기 때문에, 블록 밖의 `.box2`에서는 사용할 수 없습니다.\r\n\r\n```\r\n.box1 {\r\n  $color: #111;\r\n  background: $color;\r\n}\r\n// Error\r\n.box2 {\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\n### 변수 재 할당(Variable Reassignment)\r\n\r\n다음과 같이 변수에 변수를 할당할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$red: #FF0000;\r\n$blue: #0000FF;\r\n\r\n$color-primary: $blue;\r\n$color-danger: $red;\r\n\r\n.box {\r\n  color: $color-primary;\r\n  background: $color-danger;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  color: #0000FF;\r\n  background: #FF0000;\r\n}\r\n\r\n```\r\n\r\n### !global (전역 설정)\r\n\r\n`!global` 플래그를 사용하면 변수의 유효범위를 전역(Global)로 설정할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.box1 {\r\n  $color: #111 !global;\r\n  background: $color;\r\n}\r\n.box2 {\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  background: #111;\r\n}\r\n.box2 {\r\n  background: #111;\r\n}\r\n\r\n```\r\n\r\n대신 기존에 사용하던 같은 이름의 변수가 있을 경우 값이 덮어져 사용될 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color: #000;\r\n.box1 {\r\n  $color: #111 !global;\r\n  background: $color;\r\n}\r\n.box2 {\r\n  background: $color;\r\n}\r\n.box3 {\r\n  $color: #222;\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  background: #111;\r\n}\r\n.box2 {\r\n  background: #111;\r\n}\r\n.box3 {\r\n  background: #222;\r\n}\r\n\r\n```\r\n\r\n### !default (초깃값 설정)\r\n\r\n`!default` 플래그는 할당되지 않은 변수의 초깃값을 설정합니다.  \r\n즉, 할당되어있는 변수가 있다면 변수가 기존 할당 값을 사용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color-primary: red;\r\n\r\n.box {\r\n  $color-primary: blue !default;\r\n  background: $color-primary;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\n좀 더 유용하게, ‘변수와 값을 설정하겠지만, 혹시 기존 변수가 있을 경우는 현재 설정하는 변수의 값은 사용하지 않겠다’는 의미로 쓸 수 있습니다.  \r\n예를 들어, [Bootstrap](https://github.com/twbs/bootstrap/tree/v4-dev/scss) 같은 외부 Sass(SCSS) 라이브러리를 연결했더니 변수 이름이 같아 내가 작성한 코드의 변수들이 Overwrite(덮어쓰기) 된다면 문제가 있겠죠.  \r\n반대로 내가 만든 Sass(SCSS) 라이브러리가 다른 사용자 코드의 변수들을 Overwrite 한다면, 사용자들은 그 라이브러리를 더 이상 사용하지 않을 것입니다.  \r\n이럴 때 Sass(SCSS) 라이브러리(혹은 새롭게 만든 모듈)에서 사용하는 변수에 `!default` 플래그가 있다면 기존 코드(원본)를 Overwrite 하지 않고도 사용할 수 있습니다.\r\n\r\n```\r\n// _config.scss\r\n$color-active: red;\r\n\r\n```\r\n\r\n```\r\n// main.scss\r\n@import 'config';\r\n\r\n$color-active: blue !default;\r\n\r\n.box {\r\n  background: $color-active;  // red\r\n}\r\n\r\n```\r\n\r\n다음은 Bootstrap 코드([\\_variables.scss](https://github.com/twbs/bootstrap/blob/v4-dev/scss/_variables.scss))의 일부입니다.\r\n\r\n<script src=\"https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d.js\"></script>\r\n\r\n<table class=\"highlight tab-size js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\"><tbody><tr><td id=\"file-_variables-scss-L1\" class=\"blob-num js-line-number\" data-line-number=\"1\">&nbsp;</td><td id=\"file-_variables-scss-LC1\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-c\"><span class=\"pl-c\">//</span> stylelint-disable</span></td></tr><tr><td id=\"file-_variables-scss-L2\" class=\"blob-num js-line-number\" data-line-number=\"2\">&nbsp;</td><td id=\"file-_variables-scss-LC2\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$white</span>: <span class=\"pl-c1\">#fff</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L3\" class=\"blob-num js-line-number\" data-line-number=\"3\">&nbsp;</td><td id=\"file-_variables-scss-LC3\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-100</span>: <span class=\"pl-c1\">#f8f9fa</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L4\" class=\"blob-num js-line-number\" data-line-number=\"4\">&nbsp;</td><td id=\"file-_variables-scss-LC4\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-200</span>: <span class=\"pl-c1\">#e9ecef</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L5\" class=\"blob-num js-line-number\" data-line-number=\"5\">&nbsp;</td><td id=\"file-_variables-scss-LC5\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-300</span>: <span class=\"pl-c1\">#dee2e6</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L6\" class=\"blob-num js-line-number\" data-line-number=\"6\">&nbsp;</td><td id=\"file-_variables-scss-LC6\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-400</span>: <span class=\"pl-c1\">#ced4da</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L7\" class=\"blob-num js-line-number\" data-line-number=\"7\">&nbsp;</td><td id=\"file-_variables-scss-LC7\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-500</span>: <span class=\"pl-c1\">#adb5bd</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L8\" class=\"blob-num js-line-number\" data-line-number=\"8\">&nbsp;</td><td id=\"file-_variables-scss-LC8\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-600</span>: <span class=\"pl-c1\">#6c757d</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L9\" class=\"blob-num js-line-number\" data-line-number=\"9\">&nbsp;</td><td id=\"file-_variables-scss-LC9\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-700</span>: <span class=\"pl-c1\">#495057</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L10\" class=\"blob-num js-line-number\" data-line-number=\"10\">&nbsp;</td><td id=\"file-_variables-scss-LC10\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-800</span>: <span class=\"pl-c1\">#343a40</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L11\" class=\"blob-num js-line-number\" data-line-number=\"11\">&nbsp;</td><td id=\"file-_variables-scss-LC11\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-900</span>: <span class=\"pl-c1\">#212529</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L12\" class=\"blob-num js-line-number\" data-line-number=\"12\">&nbsp;</td><td id=\"file-_variables-scss-LC12\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$black</span>: <span class=\"pl-c1\">#000</span> <span class=\"pl-k\">!default</span>;</td></tr></tbody></table>\r\n\r\n[view raw](https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d/raw/d1f8a93d7397ca4365feb29a2ede41653271a365/_variables.scss) [\\_variables.scss](https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d#file-_variables-scss) hosted with ❤ by [GitHub](https://github.com)\r\n\r\n### #{} (문자 보간)\r\n\r\n`#{}`를 이용해서 코드의 어디든지 변수 값을 넣을 수 있습니다.\r\n\r\n```\r\n$family: unquote(\"Droid+Sans\");\r\n@import url(\"http://fonts.googleapis.com/css?family=#{$family}\");\r\n\r\n```\r\n\r\n```\r\n@import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\");\r\n\r\n```\r\n\r\nSass의 내장 함수 `unquote()`는 문자에서 따옴표를 제거합니다.\r\n\r\n## 가져오기(Import)\r\n\r\n`@import`로 외부에서 가져온 Sass 파일은 모두 단일 CSS 출력 파일로 병합됩니다.  \r\n또한, 가져온 파일에 정의된 모든 변수 또는 Mixins 등을 주 파일에서 사용할 수 있습니다.\r\n\r\nSass `@import`는 기본적으로 Sass 파일을 가져오는데, CSS `@import` 규칙으로 컴파일되는 몇 가지 상황이 있습니다.\r\n\r\n-   파일 확장자가 `.css`일 때\r\n-   파일 이름이 `http://`로 시작하는 경우\r\n-   `url()`이 붙었을 경우\r\n-   미디어쿼리가 있는 경우\r\n\r\n위의 경우 CSS `@import` 규칙대로 컴파일 됩니다.\r\n\r\n```\r\n@import \"hello.css\";\r\n@import \"http://hello.com/hello\";\r\n@import url(hello);\r\n@import \"hello\" screen;\r\n\r\n```\r\n\r\n### 여러 파일 가져오기\r\n\r\n하나의 `@import`로 여러 파일을 가져올 수도 있습니다.  \r\n파일 이름은 `,`로 구분합니다.\r\n\r\n```\r\n@import \"header\", \"footer\";\r\n\r\n```\r\n\r\n### 파일 분할(Partials)\r\n\r\n프로젝트 규모가 커지면 파일들을 `header`나 `side-menu` 같이 각 기능과 부분으로 나눠 유지보수가 쉽도록 관리하게 됩니다.  \r\n이 경우 파일이 점점 많아지는데, 모든 파일이 컴파일 시 각각의 `~.css` 파일로 나눠서 저장된다면 관리나 성능 차원에서 문제가 될 수 있겠죠.  \r\n그래서 Sass는 Partials 기능을 지원합니다.  \r\n파일 이름 앞에 `_`를 붙여(`_header.scss`와 같이) `@import`로 가져오면 컴파일 시 `~.css` 파일로 컴파일하지 않습니다.\r\n\r\n예를 들어보겠습니다.  \r\n다음과 같이 `scss/` 안에 3개의 Sass 파일이 있습니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n`main.scss`로 나머지 `~.scss` 파일을 가져옵니다.\r\n\r\n```\r\n// main.scss\r\n@import \"header\", \"side-menu\";\r\n\r\n```\r\n\r\n그리고 이 파일들을 `css/`디렉토리로 컴파일합니다.  \r\n(컴파일은 위에서 설명한 `node-sass`로 진행합니다.)\r\n\r\n```\r\n# `scss`디렉토리에 있는 파일들을 `css`디렉토리로 컴파일\r\n$ node-sass scss --output css\r\n\r\n```\r\n\r\n컴파일 후 확인하면 아래와 같이 `scss/`에 있던 파일들이 `css/` 안에 각 하나씩의 파일로 컴파일됩니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─css\r\n  │  ├─header.css\r\n  │  ├─side-menu.css\r\n  │  └─main.css\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n자, 이번에는 가져올 파일 이름에 `_`를 붙이겠습니다.  \r\n메인 파일인 `main.scss`에서는 `_`를 사용하지 않습니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─scss\r\n  │  ├─_header.scss\r\n  │  ├─_side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n```\r\n// main.scss\r\n@import \"header\", \"side-menu\";\r\n\r\n```\r\n\r\n같은 방법으로 컴파일하면…\r\n\r\n```\r\n$ node-sass scss --output css\r\n\r\n```\r\n\r\n아래처럼 별도의 파일로 컴파일되지 않고 사용됩니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─css\r\n  │  └─main.css  # main + header + side-menu\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n`Webpack`이나 `Parcel`, `Gulp` 같은 일반적인 빌드툴에서는 Partials 기능을 사용할 필요 없이, 설정된 값에 따라 빌드됩니다. 하지만 되도록 `_`를 사용할 것을 권장합니다.\r\n\r\n## 연산(Operations)\r\n\r\nSass는 기본적인 연산 기능을 지원합니다.  \r\n레이아웃 작업시 상황에 맞게 크기를 계산을 하거나 정해진 값을 나눠서 작성할 경우 유용합니다.  \r\n다음은 Sass에서 사용 가능한 연산자 종류 입니다.\r\n\r\n산술 연산자:\r\n\r\n| 종류 | 설명 | 주의사항 |\r\n| --- | --- | --- |\r\n| `+` | 더하기 |   |\r\n| `-` | 빼기 |   |\r\n| `*` | 곱하기 | 하나 이상의 값이 반드시 숫자(Number) |\r\n| `/` | 나누기 | 오른쪽 값이 반드시 숫자(Number) |\r\n| `%` | 나머지 |   |\r\n\r\n비교 연산자:\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `==` | 동등 |\r\n| `!=` | 부등 |\r\n| `<` | 대소 / 보다 작은 |\r\n| `>` | 대소 / 보다 큰 |\r\n| `<=` | 대소 및 동등 / 보다 작거나 같은 |\r\n| `>=` | 대소 및 동등 / 보다 크거나 같은 |\r\n\r\n논리(불린, Boolean) 연산자:\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `and` | 그리고 |\r\n| `or` | 또는 |\r\n| `not` | 부정 |\r\n\r\n### 숫자(Numbers)\r\n\r\n#### 상대적 단위 연산\r\n\r\n일반적으론 절댓값을 나타내는 `px` 단위로 연산을 합니다만, 상대적 단위(`%`, `em`, `vw` 등)의 연산의 경우 [CSS calc()](https://developer.mozilla.org/ko/docs/Web/CSS/calc)로 연산해야 합니다.\r\n\r\n```\r\nwidth: 50% - 20px;  // 단위 모순 에러(Incompatible units error)\r\nwidth: calc(50% - 20px);  // 연산 가능\r\n\r\n```\r\n\r\n#### 나누기 연산의 주의사항\r\n\r\nCSS는 속성 값의 숫자를 분리하는 방법으로 `/`를 허용하기 때문에 `/`가 나누기 연산으로 사용되지 않을 수 있습니다.  \r\n예를 들어, `font: 16px / 22px serif;` 같은 경우 `font-size: 16px`와 `line-height: 22px`의 속성값 분리를 위해서 `/`를 사용합니다.  \r\n아래 예제를 보면 나누기 연산자만 연산 되지 않고 그대로 컴파일됩니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  width: 20px + 20px;  // 더하기\r\n  height: 40px - 10px;  // 빼기\r\n  font-size: 10px * 2;  // 곱하기\r\n  margin: 30px / 2;  // 나누기\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 40px;  /* OK */\r\n  height: 30px;  /* OK */\r\n  font-size: 20px;  /* OK */\r\n  margin: 30px / 2;  /* ?? */\r\n}\r\n\r\n```\r\n\r\n따라서 `/`를 나누기 연산 기능으로 사용하려면 다음과 같은 조건을 충족해야 합니다.\r\n\r\n-   값 또는 그 일부가 변수에 저장되거나 함수에 의해 반환되는 경우\r\n-   값이 `()`로 묶여있는 경우\r\n-   값이 다른 산술 표현식의 일부로 사용되는 경우\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  $x: 100px;\r\n  width: $x / 2;  // 변수에 저장된 값을 나누기\r\n  height: (100px / 2);  // 괄호로 묶어서 나누기\r\n  font-size: 10px + 12px / 3;  // 더하기 연산과 같이 사용\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 50px;\r\n  height: 50px;\r\n  font-size: 14px;\r\n}\r\n\r\n```\r\n\r\n### 문자(Strings)\r\n\r\n문자 연산에는 `+`가 사용됩니다.  \r\n문자 연산의 결과는 첫 번째 피연산자를 기준으로 합니다.  \r\n첫 번째 피연산자에 따옴표가 붙어있다면 연산 결과를 따옴표로 묶습니다.  \r\n반대로 첫 번째 피연산자에 따옴표가 붙어있지 않다면 연산 결과도 따옴표를 처리하지 않습니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv::after {\r\n  content: \"Hello \" + World;\r\n  flex-flow: row + \"-reverse\" + \" \" + wrap\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv::after {\r\n  content: \"Hello World\";\r\n  flex-flow: row-reverse wrap;\r\n}\r\n\r\n```\r\n\r\n### 색상(Colors)\r\n\r\n색상도 연산할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  color: #123456 + #345678;\r\n  // R: 12 + 34 = 46\r\n  // G: 34 + 56 = 8a\r\n  // B: 56 + 78 = ce\r\n  background: rgba(50, 100, 150, .5) + rgba(10, 20, 30, .5);\r\n  // R: 50 + 10 = 60\r\n  // G: 100 + 20 = 120\r\n  // B: 150 + 30 = 180\r\n  // A: Alpha channels must be equal\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: #468ace;\r\n  background: rgba(60, 120, 180, 0.5);\r\n}\r\n\r\n```\r\n\r\nRGBA에서 Alpha 값은 연산되지 않으며 서로 동일해야 다른 값의 연산이 가능합니다.  \r\nAlpha 값을 연산하기 위한 다음과 같은 색상 함수(Color Functions)를 사용할 수 있습니다.\r\n\r\n[opacify()](http://sass-lang.com/documentation/Sass/Script/Functions.html#opacify-instance_method), [transparentize()](http://sass-lang.com/documentation/Sass/Script/Functions.html#transparentize-instance_method)\r\n\r\nSCSS:\r\n\r\n```\r\n$color: rgba(10, 20, 30, .5);\r\ndiv {\r\n  color: opacify($color, .3);  // 30% 더 불투명하게 / 0.5 + 0.3\r\n  background-color: transparentize($color, .2);  // 20% 더 투명하게 / 0.5 - 0.2\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: rgba(10, 20, 30, 0.8);\r\n  background-color: rgba(10, 20, 30, 0.3);\r\n}\r\n\r\n```\r\n\r\n### 논리(Boolean)\r\n\r\nSass의 `@if` 조건문에서 사용되는 논리(Boolean) 연산에는 ‘그리고’,’ 또는’, ‘부정’이 있습니다.  \r\n자바스크립트 문법에 익숙하다면 `&&`, `||`, `!`와 같은 기능으로 생각하면 됩니다.\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `and` | 그리고 |\r\n| `or` | 또는 |\r\n| `not` | 부정(반대) |\r\n\r\n간단한 예제를 확인하고, 더 자세한 내용은 조건문에서 살펴보겠습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$width: 90px;\r\ndiv {\r\n  @if not ($width > 100px) {\r\n    height: 300px;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  height: 300px;\r\n}\r\n\r\n```\r\n\r\n## 재활용(Mixins)\r\n\r\nSass Mixins는 스타일 시트 전체에서 **재사용 할 CSS 선언 그룹** 을 정의하는 아주 훌륭한 기능입니다.  \r\n약간의 Mixin(믹스인)으로 다양한 스타일을 만들어낼 수 있습니다.\r\n\r\n우선, Mixin은 두 가지만 기억하면 됩니다.  \r\n선언하기(`@mixin`)와 포함하기(`@include`) 입니다.  \r\n만들어서(선언), 사용(포함)하는 거죠!\r\n\r\n### @mixin\r\n\r\n기본적인 Mixin 선언은 아주 간단합니다.  \r\n`@mixin` 지시어를 이용하여 스타일을 정의합니다.\r\n\r\n```\r\n// SCSS\r\n@mixin 믹스인이름 {\r\n  스타일;\r\n}\r\n\r\n// Sass\r\n=믹스인이름\r\n  스타일\r\n\r\n```\r\n\r\n```\r\n// SCSS\r\n@mixin large-text {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\n\r\n// Sass\r\n=large-text\r\n  font-size: 22px\r\n  font-weight: bold\r\n  font-family: sans-serif\r\n  color: orange\r\n\r\n```\r\n\r\nMixin은 선택자를 포함 가능하고 상위(부모) 요소 참조(`&` 같은)도 할 수 있습니다.\r\n\r\n```\r\n@mixin large-text {\r\n  font: {\r\n    size: 22px;\r\n    weight: bold;\r\n    family: sans-serif;\r\n  }\r\n  color: orange;\r\n\r\n  &::after {\r\n    content: \"!!\";\r\n  }\r\n\r\n  span.icon {\r\n    background: url(\"/images/icon.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n### @include\r\n\r\n선언된 Mixin을 사용(포함)하기 위해서는 `@include`가 필요합니다.  \r\n위에서 선언한 Mixin을 사용해 보겠습니다.\r\n\r\n```\r\n// SCSS\r\n@include 믹스인이름;\r\n\r\n// Sass\r\n+믹스인이름\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n// SCSS\r\nh1 {\r\n  @include large-text;\r\n}\r\ndiv {\r\n  @include large-text;\r\n}\r\n\r\n// Sass\r\nh1\r\n  +large-text\r\ndiv\r\n  +large-text\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\nh1 {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\nh1::after {\r\n  content: \"!!\";\r\n}\r\nh1 span.icon {\r\n  background: url(\"/images/icon.png\");\r\n}\r\n\r\ndiv {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\ndiv::after {\r\n  content: \"!!\";\r\n}\r\ndiv span.icon {\r\n  background: url(\"/images/icon.png\");\r\n}\r\n\r\n```\r\n\r\n### 인수(Arguments)\r\n\r\nMixin은 함수(Functions)처럼 인수(Arguments)를 가질 수 있습니다.  \r\n하나의 Mixin으로 다양한 결과를 만들 수 있습니다.\r\n\r\n```\r\n// SCSS\r\n@mixin 믹스인이름($매개변수) {\r\n  스타일;\r\n}\r\n@include 믹스인이름(인수);\r\n\r\n// Sass\r\n=믹스인이름($매개변수)\r\n  스타일\r\n\r\n+믹스인이름(인수)\r\n\r\n```\r\n\r\n> 매개변수(Parameters)란 변수의 한 종류로, 제공되는 여러 데이터 중 하나를 가리키기 위해 사용된다.  \r\n> 제공되는 여러 데이터들을 전달인수(Arguments) 라고 부른다.\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin dash-line($width, $color) {\r\n  border: $width dashed $color;\r\n}\r\n\r\n.box1 { @include dash-line(1px, red); }\r\n.box2 { @include dash-line(4px, blue); }\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  border: 1px dashed red;\r\n}\r\n.box2 {\r\n  border: 4px dashed blue;\r\n}\r\n\r\n```\r\n\r\n#### 인수의 기본값 설정\r\n\r\n인수(argument)는 기본값(default value)을 가질 수 있습니다.  \r\n`@include` 포함 단계에서 별도의 인수가 전달되지 않으면 기본값이 사용됩니다.\r\n\r\n```\r\n@mixin 믹스인이름($매개변수: 기본값) {\r\n  스타일;\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin dash-line($width: 1px, $color: black) {\r\n  border: $width dashed $color;\r\n}\r\n\r\n.box1 { @include dash-line; }\r\n.box2 { @include dash-line(4px); }\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  border: 1px dashed black;\r\n}\r\n.box2 {\r\n  border: 4px dashed black;\r\n}\r\n\r\n```\r\n\r\n#### 키워드 인수(Keyword Arguments)\r\n\r\n```\r\n@mixin 믹스인이름($매개변수A: 기본값, $매개변수B: 기본값) {\r\n  스타일;\r\n}\r\n\r\n@include 믹스인이름($매개변수B: 인수);\r\n\r\n```\r\n\r\nMixin에 전달할 인수를 입력할 때 명시적으로 키워드(변수)를 입력하여 작성할 수 있습니다.  \r\n별도의 인수 입력 순서를 필요로 하지 않아 편리하게 작성할 수 있습니다.  \r\n단, 작성하지 않은 인수가 적용될 수 있도록 기본값을 설정해 주는 것이 좋습니다.\r\n\r\n```\r\n@mixin position(\r\n  $p: absolute,\r\n  $t: null,\r\n  $b: null,\r\n  $l: null,\r\n  $r: null\r\n) {\r\n  position: $p;\r\n  top: $t;\r\n  bottom: $b;\r\n  left: $l;\r\n  right: $r;\r\n}\r\n\r\n.absolute {\r\n  // 키워드 인수로 설정할 값만 전달\r\n  @include position($b: 10px, $r: 20px);\r\n}\r\n.fixed {\r\n  // 인수가 많아짐에 따라 가독성을 확보하기 위해 줄바꿈\r\n  @include position(\r\n    fixed,\r\n    $t: 30px,\r\n    $r: 40px\r\n  );\r\n}\r\n\r\n```\r\n\r\n```\r\n.absolute {\r\n  position: absolute;\r\n  bottom: 10px;\r\n  right: 20px;\r\n}\r\n.fixed {\r\n  position: fixed;\r\n  top: 30px;\r\n  right: 40px;\r\n}\r\n\r\n```\r\n\r\n#### 가변 인수(Variable Arguments)\r\n\r\n때때로 입력할 인수의 개수가 불확실한 경우가 있습니다.  \r\n그럴 경우 가변 인수를 사용할 수 있습니다.  \r\n가변 인수는 매개변수 뒤에 `...`을 붙여줍니다.\r\n\r\n```\r\n@mixin 믹스인이름($매개변수...) {\r\n  스타일;\r\n}\r\n\r\n@include 믹스인이름(인수A, 인수B, 인수C);\r\n\r\n```\r\n\r\n```\r\n// 인수를 순서대로 하나씩 전달 받다가, 3번째 매개변수($bg-values)는 인수의 개수에 상관없이 받음\r\n@mixin bg($width, $height, $bg-values...) {\r\n  width: $width;\r\n  height: $height;\r\n  background: $bg-values;\r\n}\r\n\r\ndiv {\r\n  // 위의 Mixin(bg) 설정에 맞게 인수를 순서대로 전달하다가 3번째 이후부터는 개수에 상관없이 전달\r\n  @include bg(\r\n    100px,\r\n    200px,\r\n    url(\"/images/a.png\") no-repeat 10px 20px,\r\n    url(\"/images/b.png\") no-repeat,\r\n    url(\"/images/c.png\")\r\n  );\r\n}\r\n\r\n```\r\n\r\n```\r\ndiv {\r\n  width: 100px;\r\n  height: 200px;\r\n  background: url(\"/images/a.png\") no-repeat 10px 20px,\r\n              url(\"/images/b.png\") no-repeat,\r\n              url(\"/images/c.png\");\r\n}\r\n\r\n```\r\n\r\n위에선 인수를 받는 매개변수에 `...`을 사용하여 가변 인수를 활용했습니다.  \r\n이번엔 반대로 가변 인수를 전달할 값으로 사용해 보겠습니다.\r\n\r\n```\r\n@mixin font(\r\n  $style: normal,\r\n  $weight: normal,\r\n  $size: 16px,\r\n  $family: sans-serif\r\n) {\r\n  font: {\r\n    style: $style;\r\n    weight: $weight;\r\n    size: $size;\r\n    family: $family;\r\n  }\r\n}\r\ndiv {\r\n  // 매개변수 순서와 개수에 맞게 전달\r\n  $font-values: italic, bold, 16px, sans-serif;\r\n  @include font($font-values...);\r\n}\r\nspan {\r\n  // 필요한 값만 키워드 인수로 변수에 담아 전달\r\n  $font-values: (style: italic, size: 22px);\r\n  @include font($font-values...);\r\n}\r\na {\r\n  // 필요한 값만 키워드 인수로 전달\r\n  @include font((weight: 900, family: monospace)...);\r\n}\r\n\r\n```\r\n\r\n```\r\ndiv {\r\n  font-style: italic;\r\n  font-weight: bold;\r\n  font-size: 16px;\r\n  font-family: sans-serif;\r\n}\r\nspan {\r\n  font-style: italic;\r\n  font-weight: normal;\r\n  font-size: 22px;\r\n  font-family: sans-serif;\r\n}\r\na {\r\n  font-style: normal;\r\n  font-weight: 900;\r\n  font-size: 16px;\r\n  font-family: monospace;\r\n}\r\n\r\n```\r\n\r\n### @content\r\n\r\n선언된 Mixin에 `@content`이 포함되어 있다면 해당 부분에 원하는 **스타일 블록** 을 전달할 수 있습니다.  \r\n이 방식을 사용하여 기존 Mixin이 가지고 있는 기능에 선택자나 속성 등을 추가할 수 있습니다.\r\n\r\n```\r\n@mixin 믹스인이름() {\r\n  스타일;\r\n  @content;\r\n}\r\n\r\n@include 믹스인이름() {\r\n  // 스타일 블록\r\n  스타일;\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin icon($url) {\r\n  &::after {\r\n    content: $url;\r\n    @content;\r\n  }\r\n}\r\n.icon1 {\r\n  // icon Mixin의 기존 기능만 사용\r\n  @include icon(\"/images/icon.png\");\r\n}\r\n.icon2 {\r\n  // icon Mixin에 스타일 블록을 추가하여 사용\r\n  @include icon(\"/images/icon.png\") {\r\n    position: absolute;\r\n  };\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.icon1::after {\r\n  content: \"/images/icon.png\";\r\n}\r\n.icon2::after {\r\n  content: \"/images/icon.png\";\r\n  position: absolute;\r\n}\r\n\r\n```\r\n\r\nMixin에게 전달된 스타일 블록은 Mixin의 범위가 아니라 스타일 블록이 정의된 범위에서 평가됩니다.  \r\n즉, Mixin의 매개변수는 전달된 스타일 블록 안에서 사용되지 않고 전역 값으로 해석됩니다.  \r\n전역 변수(Global variables)와 지역 변수(Local variables)를 생각하면 좀 더 쉽습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color: red;\r\n\r\n@mixin colors($color: blue) {\r\n  // Mixin의 범위\r\n  @content;\r\n  background-color: $color;\r\n  border-color: $color;\r\n}\r\n\r\ndiv {\r\n  @include colors() {\r\n    // 스타일 블록이 정의된 범위\r\n    color: $color;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: red;\r\n  background-color: blue;\r\n  border-color: blue;\r\n}\r\n\r\n```\r\n\r\n## 확장(Extend)\r\n\r\n특정 선택자가 다른 선택자의 모든 스타일을 가져야하는 경우가 종종 있습니다.  \r\n이럴 경우 선택자의 확장 기능을 사용할 수 있습니다.  \r\n다음 예제를 봅시다.\r\n\r\n```\r\n@extend 선택자;\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n.btn {\r\n  padding: 10px;\r\n  margin: 10px;\r\n  background: blue;\r\n}\r\n.btn-danger {\r\n  @extend .btn;\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.btn, .btn-danger {\r\n  padding: 10px;\r\n  margin: 10px;\r\n  background: blue;\r\n}\r\n.btn-danger {\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\n컴파일된 결과가 마음에 드시나요?  \r\n결과를 보면 `,`로 구분하는 다중 선택자(Multiple Selector)가 만들어졌습니다.\r\n\r\n사실 `@extend`는 다음과 같은 문제를 고려해야 합니다.\r\n\r\n-   내 현재 선택자(위 예제의 `.btn-danger`)가 어디에 첨부될 것인가?\r\n-   원치 않는 부작용이 초래될 수도 있는가?\r\n-   이 한 번의 확장으로 얼마나 큰 CSS가 생성되는가?\r\n\r\n결과적으로 확장(Extend) 기능은 무해하거나 혹은 유익할 수도 있지만 그만큼 **부작용**을 가지고 있을 수 있습니다.  \r\n따라서 확장은 사용을 권장하지 않으며, 위에서 살펴본 **Mixin을 대체 기능으로 사용**하세요.\r\n\r\n사용을 권장하지 않는 이유에 대해서 좀 더 자세한 정보를 원하면 [Sass Guidelines Extend](https://sass-guidelin.es/ko/#extend)를 참고하세요.\r\n\r\n## 함수(Functions)\r\n\r\n자신의 함수를 정의하여 사용할 수 있습니다.  \r\n함수와 Mixins은 거의 유사하지만 반환되는 내용이 다릅니다.\r\n\r\nMixin은 위에서 살펴본 대로 지정한 스타일(Style)을 반환하는 반면,  \r\n함수는 보통 연산된(Computed) 특정 **값**을 `@return` 지시어를 통해 반환합니다.\r\n\r\n```\r\n// Mixins\r\n@mixin 믹스인이름($매개변수) {\r\n  스타일;\r\n}\r\n\r\n// Functions\r\n@function 함수이름($매개변수) {\r\n  @return 값\r\n}\r\n\r\n```\r\n\r\n사용하는 방법에도 차이가 있습니다.  \r\nMixin은 `@include` 지시어를 사용하는 반면,  \r\n함수는 함수이름으로 바로 사용합니다.\r\n\r\n```\r\n// Mixin\r\n@include 믹스인이름(인수);\r\n\r\n// Functions\r\n함수이름(인수)\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$max-width: 980px;\r\n\r\n@function columns($number: 1, $columns: 12) {\r\n  @return $max-width * ($number / $columns)\r\n}\r\n\r\n.box_group {\r\n  width: $max-width;\r\n\r\n  .box1 {\r\n    width: columns();  // 1\r\n  }\r\n  .box2 {\r\n    width: columns(8);\r\n  }\r\n  .box3 {\r\n    width: columns(3);\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box_group {\r\n  /* 총 너비 */\r\n  width: 980px;\r\n}\r\n.box_group .box1 {\r\n  /* 총 너비의 약 8.3% */\r\n  width: 81.66667px;\r\n}\r\n.box_group .box2 {\r\n  /* 총 너비의 약 66.7% */\r\n  width: 653.33333px;\r\n}\r\n.box_group .box3 {\r\n  /* 총 너비의 25% */\r\n  width: 245px;\r\n}\r\n\r\n```\r\n\r\n위와 같이 함수는 `@include` 같은 별도의 지시어 없이 사용하기 때문에 내가 지정한 함수와 내장 함수(Built-in Functions)의 이름이 충돌할 수 있습니다.  \r\n따라서 내가 지정한 함수에는 별도의 접두어를 붙여주는 것이 좋습니다.\r\n\r\n> 내장 함수란, 응용 프로그램에 내장되어 있으며 최종 사용자가 액세스 할 수 있는 기능입니다.  \r\n> 예를 들어, 대부분의 스프레드 시트 응용 프로그램은 행이나 열의 모든 셀을 추가하는 내장 SUM 함수를 지원합니다.\r\n\r\n예를 들어, 색의 빨강 성분을 가져오는 내장 함수로 이미 `red()`가 있습니다.  \r\n같은 이름을 사용하여 함수를 정의하면 이름이 충돌하기 때문에 별도의 접두어를 붙여 `extract-red()` 같은 이름을 만들 수 있습니다.\r\n\r\n```\r\n// 내가 정의한 함수\r\n@function extract-red($color) {\r\n  // 내장 함수\r\n  @return rgb(red($color), 0, 0);\r\n}\r\n\r\ndiv {\r\n  color: extract-red(#D55A93);\r\n}\r\n\r\n```\r\n\r\n혹은 모든 내장 함수의 이름을 다 알고 있을 수 없기 때문에 특별한 이름을 접두어로 사용할 수도 있습니다.  \r\n`my-custom-func-red()`\r\n\r\n## 조건과 반복(Control Directives / Expressions)\r\n\r\n### if (함수)\r\n\r\n조건의 값(`true`, `false`)에 따라 두 개의 표현식 중 하나만 반환합니다.  \r\n[조건부 삼항 연산자(conditional ternary operator)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)와 비슷합니다.\r\n\r\n조건의 값이 `true`이면 `표현식1`을,  \r\n조건의 값이 `false`이면 `표현식2`를 실행합니다.\r\n\r\n```\r\nif(조건, 표현식1, 표현식2)\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$width: 555px;\r\ndiv {\r\n  width: if($width > 300px, $width, null);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 555px;\r\n}\r\n\r\n```\r\n\r\n### @if (지시어)\r\n\r\n`@if` 지시어는 조건에 따른 분기 처리가 가능하며, [if 문(if statements)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/if...else)과 유사합니다.  \r\n같이 사용할 수 있는 지시어는 `@else`, `if`가 있습니다.  \r\n추가 지시어를 사용하면 좀 더 복잡한 조건문을 작성할 수 있습니다.\r\n\r\n```\r\n// @if\r\n@if (조건) {\r\n  /* 조건이 참일 때 구문 */\r\n}\r\n\r\n// @if @else\r\n@if (조건) {\r\n  /* 조건이 참일 때 구문 */\r\n} @else {\r\n  /* 조건이 거짓일 때 구문 */\r\n}\r\n\r\n// @if @else if\r\n@if (조건1) {\r\n  /* 조건1이 참일 때 구문 */\r\n} @else if (조건2) {\r\n  /* 조건2가 참일 때 구문 */\r\n} @else {\r\n  /* 모두 거짓일 때 구문 */\r\n}\r\n\r\n```\r\n\r\n조건에 `()`는 생략이 가능하기 때문에, `()` 없이 작성하는 방법이 좀 더 편리할 수 있습니다.\r\n\r\n```\r\n$bg: true;\r\ndiv {\r\n  @if $bg {\r\n    background: url(\"/images/a.jpg\");\r\n  }\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$color: orange;\r\ndiv {\r\n  @if $color == strawberry {\r\n    color: #FE2E2E;\r\n  } @else if $color == orange {\r\n    color: #FE9A2E;\r\n  } @else if $color == banana {\r\n    color: #FFFF00;\r\n  } @else {\r\n    color: #2A1B0A;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: #FE9A2E;\r\n}\r\n\r\n```\r\n\r\n조건에는 논리 연산자 `and`, `or`, `not`을 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n@function limitSize($size) {\r\n  @if $size >= 0 and $size <= 200px {\r\n    @return 200px;\r\n  } @else {\r\n    @return 800px;\r\n  }\r\n}\r\n\r\ndiv {\r\n  width: limitSize(180px);\r\n  height: limitSize(340px);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 200px;\r\n  height: 800px;\r\n}\r\n\r\n```\r\n\r\n좀 더 복잡하지만 실용적인 예제를 봅시다.  \r\nSass의 내장 함수 `unitless()`는 숫자에 단위가 있는지 여부를 반환합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin pCenter($w, $h, $p: absolute) {\r\n  @if\r\n    $p == absolute\r\n    or $p == fixed\r\n    or not $p == relative\r\n    or not $p == static\r\n  {\r\n    width: if(unitless($w), #{$w}px, $w);\r\n    height: if(unitless($h), #{$h}px, $h);\r\n    position: $p;\r\n    top: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    margin: auto;\r\n  }\r\n}\r\n\r\n.box1 {\r\n  @include pCenter(10px, 20px);\r\n}\r\n.box2 {\r\n  @include pCenter(50, 50, fixed);\r\n}\r\n.box3 {\r\n  @include pCenter(100, 200, relative);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  width: 10px;\r\n  height: 20px;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  margin: auto;\r\n}\r\n\r\n.box2 {\r\n  width: 50px;\r\n  height: 50px;\r\n  position: fixed;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  margin: auto;\r\n}\r\n\r\n```\r\n\r\n### @for\r\n\r\n`@for`는 스타일을 반복적으로 출력합니다.  \r\n[for 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for)과 유사합니다.\r\n\r\n`@for`는 `through`를 사용하는 형식과 `to`를 사용하는 형식으로 나뉩니다.  \r\n두 형식은 종료 조건이 해석되는 방식이 다릅니다.\r\n\r\n```\r\n// through\r\n// 종료 만큼 반복\r\n@for $변수 from 시작 through 종료 {\r\n  // 반복 내용\r\n}\r\n\r\n// to\r\n// 종료 직전까지 반복\r\n@for $변수 from 시작 to 종료 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n차이점을 이해하기 위해 다음 예제를 살펴봅시다.  \r\n변수는 관례상 `$i`를 사용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n// 1부터 3번 반복\r\n@for $i from 1 through 3 {\r\n  .through:nth-child(#{$i}) {\r\n    width : 20px * $i\r\n  }\r\n}\r\n\r\n// 1부터 3 직전까지만 반복(2번 반복)\r\n@for $i from 1 to 3 {\r\n  .to:nth-child(#{$i}) {\r\n    width : 20px * $i\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.through:nth-child(1) { width: 20px; }\r\n.through:nth-child(2) { width: 40px; }\r\n.through:nth-child(3) { width: 60px; }\r\n\r\n.to:nth-child(1) { width: 20px; }\r\n.to:nth-child(2) { width: 40px; }\r\n\r\n```\r\n\r\n`to`는 주어진 값 직전까지만 반복해야할 경우 유용할 수 있습니다.  \r\n그러나 `:nth-child()`에서 특히 유용하게 사용되는 `@for`는 일반적으로 `through`를 사용하길 권장합니다.\r\n\r\n### @each\r\n\r\n`@each`는 List와 Map 데이터를 반복할 때 사용합니다.  \r\n[for in 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...in)과 유사합니다.\r\n\r\n```\r\n@each $변수 in 데이터 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\nList 데이터를 반복해 보겠습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n// List Data\r\n$fruits: (apple, orange, banana, mango);\r\n\r\n.fruits {\r\n  @each $fruit in $fruits {\r\n    li.#{$fruit} {\r\n      background: url(\"/images/#{$fruit}.png\");\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fruits li.apple {\r\n  background: url(\"/images/apple.png\");\r\n}\r\n.fruits li.orange {\r\n  background: url(\"/images/orange.png\");\r\n}\r\n.fruits li.banana {\r\n  background: url(\"/images/banana.png\");\r\n}\r\n.fruits li.mango {\r\n  background: url(\"/images/mango.png\");\r\n}\r\n\r\n```\r\n\r\n혹시 매번 반복마다 Index 값이 필요하다면 다음과 같이 `index()` 내장 함수를 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$fruits: (apple, orange, banana, mango);\r\n\r\n.fruits {\r\n  @each $fruit in $fruits {\r\n    $i: index($fruits, $fruit);\r\n    li:nth-child(#{$i}) {\r\n      left: 50px * $i;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fruits li:nth-child(1) {\r\n  left: 50px;\r\n}\r\n.fruits li:nth-child(2) {\r\n  left: 100px;\r\n}\r\n.fruits li:nth-child(3) {\r\n  left: 150px;\r\n}\r\n.fruits li:nth-child(4) {\r\n  left: 200px;\r\n}\r\n\r\n```\r\n\r\n동시에 여러 개의 List 데이터를 반복 처리할 수도 있습니다.  \r\n단, 각 데이터의 Length가 같아야 합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$apple: (apple, korea);\r\n$orange: (orange, china);\r\n$banana: (banana, japan);\r\n\r\n@each $fruit, $country in $apple, $orange, $banana {\r\n  .box-#{$fruit} {\r\n    background: url(\"/images/#{$country}.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box-apple {\r\n  background: url(\"/images/korea.png\");\r\n}\r\n.box-orange {\r\n  background: url(\"/images/china.png\");\r\n}\r\n.box-banana {\r\n  background: url(\"/images/japan.png\");\r\n}\r\n\r\n```\r\n\r\nMap 데이터를 반복할 경우 하나의 데이터에 두 개의 변수가 필요합니다.\r\n\r\n```\r\n@each $key변수, $value변수 in 데이터 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n```\r\n$fruits-data: (\r\n  apple: korea,\r\n  orange: china,\r\n  banana: japan\r\n);\r\n\r\n@each $fruit, $country in $fruits-data {\r\n  .box-#{$fruit} {\r\n    background: url(\"/images/#{$country}.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n```\r\n.box-apple {\r\n  background: url(\"/images/korea.png\");\r\n}\r\n.box-orange {\r\n  background: url(\"/images/china.png\");\r\n}\r\n.box-banana {\r\n  background: url(\"/images/japan.png\");\r\n}\r\n\r\n```\r\n\r\n### @while\r\n\r\n`@while`은 조건이 `false`로 평가될 때까지 내용을 반복합니다.  \r\n[while 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/while)과 유사하게 잘못된 조건으로 인해 컴파일 중 무한 루프에 빠질 수 있습니다.  \r\n사용을 권장하지 않습니다.\r\n\r\n```\r\n@while 조건 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n```\r\n$i: 6;\r\n\r\n@while $i > 0 {\r\n  .item-#{$i} {\r\n    width: 2px * $i;\r\n  }\r\n  $i: $i - 2;\r\n}\r\n\r\n```\r\n\r\n```\r\n.item-6 { width: 12px; }\r\n.item-4 { width: 8px; }\r\n.item-2 { width: 4px; }\r\n\r\n```\r\n\r\n## 내장 함수(Built-in Functions)\r\n\r\nSass에서 기본적으로 제공하는 내장 함수에는 많은 종류가 있습니다.  \r\n모두 소개하지 않고, 주관적 경험에 의거해 필요하거나 필요할 수 있는 함수만 정리했습니다.\r\n\r\n[Sass Built-in Functions](http://sass-lang.com/documentation/Sass/Script/Functions.html)에서 모든 내장 함수를 확인할 수 있습니다.\r\n\r\n-   `[]`는 선택 가능한 인수(argument)입니다.\r\n-   [Zero-based numbering](https://en.wikipedia.org/wiki/Zero-based_numbering)을 사용하지 않습니다.\r\n\r\n### 색상(RGB / HSL / Opacity) 함수\r\n\r\n[mix($color1, $color2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method) : 두 개의 색을 섞습니다.\r\n\r\n[lighten($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#lighten-instance_method) : 더 밝은색을 만듭니다.\r\n\r\n[darken($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#darken-instance_method) : 더 어두운색을 만듭니다.\r\n\r\n[saturate($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#saturate-instance_method) : 색상의 채도를 올립니다.\r\n\r\n[desaturate($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#desaturate-instance_method) : 색상의 채도를 낮춥니다.\r\n\r\n[grayscale($color)](http://sass-lang.com/documentation/Sass/Script/Functions.html#grayscale-instance_method) : 색상을 회색으로 변환합니다.\r\n\r\n[invert($color)](http://sass-lang.com/documentation/Sass/Script/Functions.html#invert-instance_method) : 색상을 반전시킵니다.\r\n\r\n[rgba($color, $alpha)](http://sass-lang.com/documentation/Sass/Script/Functions.html#rgba-instance_method) : 색상의 투명도를 변경합니다.\r\n\r\n[opacify($color, $amount) / fade-in($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#opacify-instance_method) : 색상을 더 불투명하게 만듭니다.\r\n\r\n[transparentize($color, $amount) / fade-out($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#transparentize-instance_method) : 색상을 더 투명하게 만듭니다.\r\n\r\n### 문자(String) 함수\r\n\r\n[unquote($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unquote-instance_method) : 문자에서 따옴표를 제거합니다.\r\n\r\n[quote($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#quote-instance_method) : 문자에 따옴표를 추가합니다.\r\n\r\n[str-insert($string, $insert, $index)](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_insert-instance_method) : 문자의 index번째에 특정 문자를 삽입합니다.\r\n\r\n[str-index($string, $substring)](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_index-instance_method) : 문자에서 특정 문자의 첫 index를 반환합니다.\r\n\r\n[str-slice($string, $start-at, \\[$end-at\\])](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_slice-instance_method) : 문자에서 특정 문자(몇 번째 글자부터 몇 번째 글자까지)를 추출합니다.\r\n\r\n[to-upper-case($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#to_upper_case-instance_method) : 문자를 대문자를 변환합니다.\r\n\r\n[to-lower-case($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#to_lower_case-instance_method) : 문자를 소문자로 변환합니다.\r\n\r\n### 숫자(Number) 함수\r\n\r\n[percentage($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#percentage-instance_method) : 숫자(단위 무시)를 백분율로 변환합니다.\r\n\r\n[round($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#round-instance_method) : 정수로 반올림합니다.\r\n\r\n[ceil($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#ceil-instance_method) : 정수로 올림합니다.\r\n\r\n[floor($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#floor-instance_method) : 정수로 내림(버림)합니다.\r\n\r\n[abs($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#abs-instance_method) : 숫자의 절대 값을 반환합니다.\r\n\r\n[min($numbers…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#min-instance_method) : 숫자 중 최소 값을 찾습니다.\r\n\r\n[max($numbers…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#max-instance_method) : 숫자 중 최대 값을 찾습니다.\r\n\r\n[random()](http://sass-lang.com/documentation/Sass/Script/Functions.html#random-instance_method) : `0` 부터 `1` 사이의 난수를 반환합니다.\r\n\r\n### List 함수\r\n\r\n모든 List 내장 함수는 기존 List 데이터를 갱신하지 않고 새 List 데이터를 반환합니다.  \r\n모든 List 내장 함수는 Map 데이터에서도 사용할 수 있습니다.\r\n\r\n[length($list)](http://sass-lang.com/documentation/Sass/Script/Functions.html#length-instance_method) : List의 개수를 반환합니다.\r\n\r\n[nth($list, $n)](http://sass-lang.com/documentation/Sass/Script/Functions.html#nth-instance_method) : List에서 n번째 값을 반환합니다.\r\n\r\n[set-nth($list, $n, $value)](http://sass-lang.com/documentation/Sass/Script/Functions.html#set_nth-instance_method) : List에서 n번째 값을 다른 값으로 변경합니다.\r\n\r\n[join($list1, $list2, \\[$separator\\])](http://sass-lang.com/documentation/Sass/Script/Functions.html#join-instance_method) : 두 개의 List를 하나로 결합합니다.\r\n\r\n[zip($lists…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#zip-instance_method) : 여러 List들을 하나의 다차원 List로 결합합니다.\r\n\r\n[index($list, $value)](http://sass-lang.com/documentation/Sass/Script/Functions.html#index-instance_method) : List에서 특정 값의 index를 반환합니다.\r\n\r\n### Map 함수\r\n\r\n모든 Map 내장 함수는 기존 Map 데이터를 갱신하지 않고 새 Map 데이터를 반환합니다.\r\n\r\n[map-get($map, $key)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_get-instance_method) : Map에서 특정 key의 value를 반환합니다.\r\n\r\n[map-merge($map1, $map2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_merge-instance_method) : 두 개의 Map을 병합하여 새로운 Map를 만듭니다.\r\n\r\n[map-keys($map)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_keys-instance_method) : Map에서 모든 key를 List로 반환합니다.\r\n\r\n[map-values($map)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_values-instance_method) : Map에서 모든 value를 List로 반환합니다.\r\n\r\n### 관리(Introspection) 함수\r\n\r\n[variable-exists(name)](http://sass-lang.com/documentation/Sass/Script/Functions.html#variable_exists-instance_method) : 변수가 현재 범위에 존재하는지 여부를 반환합니다.(인수는 `$`없이 변수의 이름만 사용합니다.)\r\n\r\n[unit($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unit-instance_method) : 숫자의 단위를 반환합니다.\r\n\r\n[unitless($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unitless-instance_method) : 숫자에 단위가 있는지 여부를 반환합니다.\r\n\r\n[comparable($number1, $number2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#comparable-instance_method) : 두 개의 숫자가 연산 가능한지 여부를 반환합니다.\r\n\r\n# 참고 자료(References)\r\n\r\n[http://sass-lang.com/documentation](http://sass-lang.com/documentation)  \r\n[https://www.sitepoint.com/sass-basics-operators/](https://www.sitepoint.com/sass-basics-operators/)  \r\n[https://sass-guidelin.es/ko/](https://sass-guidelin.es/ko/)  \r\n[http://www.thesassway.com/](http://www.thesassway.com/)","memberId":1,"boardId":3,"regDate":"2020-12-20 01:25:13","updateDate":"2021-01-15 20:54:38","extra_writer":"D.K","extra_boardName":"html&CSS","extra_boardCode":"html&CSS","rcmCount":2,"hit":2,"commentsCount":4}],"SCSS":[{"id":1,"title":"SCSS(Sacc)정리?????","body":"CSS는 상대적으로 배우기 쉽고 재미있습니다.  \r\n웹 개발 초심자에게는 이만큼 접근하기 좋은 게 없죠.\r\n\r\nCSS는 분명 쉽고 재밌지만, 작업이 고도화될수록 불편함도 같이 커집니다.  \r\n불필요한 선택자(Selector)의 과용과 연산 기능의 한계, 구문(Statement)의 부재 등 프로젝트의 규모가 커질수록 아쉬움도 같이 커지죠.  \r\n하지만 웹에서는 표준 CSS만 동작할 수 있기 때문에 다른 선택권이 없습니다.\r\n\r\n그렇다면 우리는 앞으로 계속 CSS만 사용해야 할까요?\r\n\r\n# CSS Preprocessor 란?\r\n\r\nHTML, CSS를 다루는 분이라면 한 번은 들어봤을 Sass, Less 등이 있습니다.  \r\n이 친구들은 CSS 전(예비)처리기 입니다.  \r\n보통 CSS Preprocessor 라고 부릅니다.\r\n\r\nCSS가 동작하기 전에 사용하는 기능으로,  \r\n웹에서는 분명 CSS가 동작하지만 우리는 CSS의 불편함을 이런 확장 기능으로 상쇄할 수 있습니다.\r\n\r\n> 사스는 기초 언어에 힘과 우아함을 더해주는 CSS의 확장이다.\r\n\r\n### 어떻게 사용하나요?\r\n\r\n위에서 언급한 것처럼 웹에서는 CSS만 동작합니다.  \r\n[Sass](https://sass-lang.com/), [Less](http://lesscss.org/), [Stylus](http://stylus-lang.com/) 같은 전처리기(이하 ‘전처리기’로 표기)는 직접 동작시킬 수 없습니다.  \r\n그렇다면 어떻게 사용할 수 있을까요?\r\n\r\nCSS는 불편하니 일단 배제하고 우선 전처리기로 작성(코딩)합니다.  \r\n전처리기는 CSS 문법과 굉장히 유사하지만 선택자의 중첩(Nesting)이나 조건문, 반복문, 다양한 단위(Unit)의 연산 등… 표준 CSS 보다 훨씬 많은 기능을 사용해서 편리하게 작성할 수 있습니다.  \r\n단, 웹에서는 직접 동작하지 않으니 이렇게 작성한 전처리기를 웹에서 동작 가능한 표준의 CSS로 컴파일(Compile)합니다.  \r\n전처리기로 작성하고 CSS로 컴파일해서 동작시키는 거죠.\r\n\r\n### 컴파일은 어떻게 하나요?\r\n\r\n전처리기 종류마다 방법이 조금씩 다르고 여러 방식을 제공합니다.  \r\n보통의 경우 컴파일러(Compiler)가 필요합니다.  \r\n우리는 이제 Sass(SCSS)를 알아볼 것이고 컴파일 방법에 대해서도 같이 살펴보겠습니다.\r\n\r\n### 왜 Sass(SCSS)죠?\r\n\r\n보통 언급되는 전처리기 3대장으로 Less, Sass(SCSS), Stylus가 있습니다.\r\n\r\n저는 가장 많이 사용하고 진입장벽이 비교적 낮았던 Less를 처음 사용했습니다.  \r\n기본적인 기능은 전처리기들이 다 비슷합니다만 개인적으로 Less는 몇몇 기능에 큰 아쉬움이 있었습니다.  \r\n정확하게 언급하진 않겠지만 프로젝트 진행 중 Less에서 제공하는 기능의 한계로 막히는 경우가 몇 번 있었는데 그 기능이 Sass나 Stylus에는 있었습니다.  \r\n하지만 진입장벽이 낮기 때문에 접하기 쉽고 그만큼 많이 사용되는 듯합니다.\r\n\r\nStylus 같은 경우는 현재 이 블로그(HEROPY)를 만들면서 사용하고 있습니다.  \r\n깔끔하고 좀 더 세련됐으며 기능도 훌륭합니다.  \r\n하지만 덜 사용되며(덜 유명하며) 비교적 늦게 나왔기 때문에 성숙도는 떨어집니다.  \r\n그 때문인지 컴파일 후 사소한 버그가 몇몇 보입니다.\r\n\r\nSass(SCSS)는 언급한 두 가지 전처리기의 장점을 모두 가집니다.  \r\n문법은 Sass가 Stylus와 비슷하고, SCSS는 Less와 비슷하며, Sass와 SCSS는 하나의 컴파일러로 모두 컴파일 가능합니다.  \r\n또한, 2006년부터 시작하여 가장 오래된 CSS 확장 언어이며 그만큼 높은 성숙도와 많은 커뮤니티를 가지고 있고 기능도 훌륭합니다.  \r\n그래서 저는 Sass(SCSS)를 선택했습니다.\r\n\r\n### Sass와 SCSS는 차이점은 뭔가요?\r\n\r\nSass(Syntactically Awesome Style Sheets)의 3버전에서 새롭게 등장한 SCSS는 CSS 구문과 완전히 호환되도록 새로운 구문을 도입해 만든 Sass의 모든 기능을 지원하는 CSS의 상위집합(Superset) 입니다.  \r\n즉, SCSS는 CSS와 거의 같은 문법으로 Sass 기능을 지원한다는 말입니다.\r\n\r\n더 쉽고 간단한 차이는 `{}`(중괄호)와 `;`(세미콜론)의 유무입니다.  \r\n아래의 예제를 비교해 보세요.\r\n\r\nSass:\r\n\r\n```sass\r\n.list\r\n  width: 100px\r\n  float: left\r\n  li\r\n    color: red\r\n    background: url(\"./image.jpg\")\r\n    &:last-child\r\n      margin-right: -10px\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```scss\r\n.list {\r\n  width: 100px;\r\n  float: left;\r\n  li {\r\n    color: red;\r\n    background: url(\"./image.jpg\");\r\n    &:last-child {\r\n      margin-right: -10px;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nSass는 선택자의 유효범위를 ‘들여쓰기’로 구분하고, SCSS는 `{}`로 범위를 구분합니다.  \r\nSass 방식과 SCSS 방식 중 어떤 방식이 마음에 드세요?\r\n\r\n거의 유일합니다만, 다른 차이도 있습니다.  \r\n아래는 Mixins(‘믹스인’은 재사용 가능한 기능을 만드는 방식의 의미합니다) 예제입니다.  \r\nSass는 단축 구문으로 사용합니다.\r\n\r\n:Sass\r\n\r\n```sass\r\n=border-radius($radius)\r\n  -webkit-border-radius: $radius\r\n  -moz-border-radius:    $radius\r\n  -ms-border-radius:     $radius\r\n  border-radius:         $radius\r\n\r\n.box\r\n  +border-radius(10px)\r\n\r\n```\r\n\r\n:SCSS\r\n\r\n```scss\r\n@mixin border-radius($radius) {\r\n  -webkit-border-radius: $radius;\r\n     -moz-border-radius: $radius;\r\n      -ms-border-radius: $radius;\r\n          border-radius: $radius;\r\n}\r\n\r\n.box { @include border-radius(10px); }\r\n\r\n```\r\n\r\nSass는 `=`와 `+` 기호로 Mixins 기능을 사용했고,  \r\nSCSS는 `@mixin`과 `@include`로 기능을 사용했습니다.\r\n\r\n단순한 몇 가지를 제외하면 거의 차이가 없지만 복잡한 문장이 될 경우 여러 환경에 따른 장단점이 있을 수 있습니다.  \r\nSass는 좀 더 간결하고 작성하기 편리하며, `{}`나 `;`를 사용하지 않아도 되니 코드가 훨씬 깔끔해집니다.  \r\nSCSS는 인라인 코드(한 줄 작성)를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉽습니다.\r\n\r\n이렇게 몇몇 장단점이 있기 때문에 회사나 팀에서 원하는 방식을 사용해야 하거나, 개인 취향에 따라서 선택할 수 있습니다.  \r\n단지 상황에 맞는, 원하는 방식으로 골라서 사용하면 됩니다.\r\n\r\n보통의 경우 SCSS를 추천합니다.\r\n\r\n# 컴파일 방법\r\n\r\nSass(SCSS)는 웹에서 직접 동작할 수 없습니다.  \r\n어디까지나 최종에는 표준 CSS로 동작해야 하며, 우리는 전처리기로 작성 후 CSS로 컴파일해야 합니다.  \r\n다양한 방법으로 컴파일이 가능하지만 자바스크립트 개발 환경([Node.js](https://nodejs.org/ko/))에서 추천하는 몇가지 방법을 소개합니다.\r\n\r\n### SassMeister\r\n\r\n간단한 Sass 코드는 컴파일러를 설치하는게 부담될 수 있습니다.  \r\n그럴 경우 [SassMeister](https://www.sassmeister.com/)를 사용할 수 있습니다.\r\n\r\n페이지 접속 후 바로 Sass나 SCSS 문법으로 코딩하면 CSS로 실시간 변환됩니다.  \r\nHTML를 작성하여 적용된 결과를 보거나 Sass 버전 설정 등 여러 환경 설정들을 지원하니 학습에 도움이 될 것입니다.\r\n\r\n### node-sass\r\n\r\n[node-sass](https://github.com/sass/node-sass)는 Node.js를 컴파일러인 [LibSass](https://sass-lang.com/libsass)에 바인딩한 라이브러리 입니다.  \r\nNPM으로 전역 설치하여 사용합니다.\r\n\r\n```sass\r\n$ npm install -g node-sass\r\n\r\n```\r\n\r\n컴파일하려는 파일의 경로와 컴파일된 파일이 저장될 경로를 설정합니다.  \r\n`[]`는 선택사항입니다.\r\n\r\n```sass\r\n$ node-sass [옵션] <입력파일경로> [출력파일경로]\r\n\r\n```\r\n\r\n```sass\r\n$ node-sass scss/main.scss public/main.css\r\n\r\n```\r\n\r\n여러 출력 경로를 설정할 수 있습니다.\r\n\r\n```sass\r\n$ node-sass scss/main.scss public/main.css dist/style.css\r\n\r\n```sass\r\n\r\n옵션을 적용할 수도 있습니다.  \r\n옵션으로 `--watch` 혹은 `-w`를 입력하면, 런타임 중 파일을 감시하여 저장 시 자동으로 변경 사항을 컴파일합니다.\r\n\r\n```sass\r\n$ node-sass --watch scss/main.scss public/main.css\r\n\r\n```\r\n\r\n기타 옵션은 [node-sass CLI](https://github.com/sass/node-sass#command-line-interface)에서 확인할 수 있습니다.\r\n\r\n### Gulp\r\n\r\n빌드 자동화 도구(JavaScript Task Runner)인 [Gulp](https://gulpjs.com/)에서는 `gulpfile.js`을 만들어 아래와 같이 설정할 수 있습니다.  \r\n먼저 `gulp` 명령을 사용하기 위해서는 전역 설치가 필요합니다.\r\n\r\n```sass\r\n$ npm install -g gulp\r\n\r\n```\r\n\r\nGulp와 함께 Sass 컴파일러인 [gulp-sass](https://github.com/dlmanning/gulp-sass)를 개발 의존성(devDependency) 모드로 설치합니다.  \r\ngulp-sass는 위에서 살펴본 node-sass를 Gulp에서 사용할 수 있도록 만들어진 플러그인입니다.\r\n\r\n```sass\r\n$ npm install --save-dev gulp gulp-sass\r\n\r\n```\r\n\r\n```java\r\n// gulpfile.js\r\nvar gulp = require('gulp')\r\nvar sass = require('gulp-sass')\r\n\r\n// 일반 컴파일\r\ngulp.task('sass', function () {\r\n  return gulp.src('./src/scss/*.scss')  // 입력 경로\r\n    .pipe(sass().on('error', sass.logError))\r\n    .pipe(gulp.dest('./dist/css'));  // 출력 경로\r\n});\r\n\r\n// 런타임 중 파일 감시\r\ngulp.task('sass:watch', function () {\r\n  gulp.watch('./src/scss/*.scss', ['sass']);  // 입력 경로와 파일 변경 감지 시 실행할 Actions(Task Name)\r\n});\r\n\r\n```\r\n\r\n환경을 설정했으니 컴파일합니다.\r\n\r\n```java\r\n$ gulp sass\r\n\r\n```\r\n\r\n런타임 중 파일 감시 모드로 실행할 수도 있습니다.\r\n\r\n```java\r\n$ gulp sass:watch\r\n\r\n```\r\n\r\n### Webpack\r\n\r\nJavaScript 모듈화 도구인 [Webpack](https://webpack.js.org/)의 설정은 좀 더 복잡합니다.  \r\n[Webpack - 1 - 시작하기 / EJS / SASS(SCSS)](https://heropy.blog/2017/10/18/webpack_1_start_ejs_sass/) 포스트를 참고하세요.\r\n\r\n### Parcel\r\n\r\n웹 애플리케이션 번들러 [Parcel](https://parceljs.org/)은 굉장히 단순하게 컴파일할 수 있습니다.  \r\n좀 더 자세한 내용은 [Parcel - 시작하기 / SASS / PostCSS / Babel / Production](https://heropy.blog/2018/01/20/parcel-1-start/)을 참고하세요.\r\n\r\n우선 Parcel를 전역으로 설치합니다.\r\n\r\n```java\r\n$ npm install -g parcel-bundler\r\n\r\n```\r\n\r\n프로젝트에 Sass 컴파일러(node-sass)를 설치합니다.\r\n\r\n```java\r\n$ npm install --save-dev node-sass\r\n\r\n```\r\n\r\n이제 HTML에 `<link>`로 Sass 파일만 연결하면 됩니다.  \r\n다른 설정은 필요하지 않습니다.\r\n\r\n```java\r\n<link rel=\"stylesheet\" href=\"scss/main.scss\">\r\n\r\n```\r\n\r\n```java\r\n$ parcel index.html\r\n# 혹은\r\n$ parcel build index.html\r\n\r\n```\r\n\r\n`dist/`에서 컴파일된 Sass 파일을 볼 수 있고,  \r\n별도의 포트 번호를 설정하지 않았다면 `[http://localhost:1234](http://localhost:1234)`에 접속하여 적용 상태를 확인할 수 있습니다.\r\n\r\n# 문법(Syntax)\r\n\r\n위의 ‘Sass와 SCSS의 차이점’에서 설명한대로 Sass와 SCSS의 기능은 동일하니, 편의를 위해 SCSS 문법으로 설명을 진행합니다.  \r\n단, Sass와 SCSS의 차이점이 있다면 나눠 설명합니다.\r\n\r\n## 주석(Comment)\r\n\r\nCSS 주석은 `/* ... */` 입니다.  \r\nSass(SCSS)는 JavaScript처럼 두 가지 스타일의 주석을 사용합니다.\r\n\r\n```css\r\n// 컴파일되지 않는 주석\r\n/* 컴파일되는 주석 */\r\n\r\n```\r\n\r\nSass의 경우 컴파일되는 여러 줄 주석을 사용할 때 각 줄 앞에 `*`을 붙여야 하고, 중요한 것은 `*`의 라인을 맞춰줘야 합니다.\r\n\r\nSass:\r\n\r\n```css\r\n/* 컴파일되는\r\n * 여러 줄\r\n * 주석 */\r\n\r\n// Error\r\n/* 컴파일되는\r\n* 여러 줄\r\n    * 주석 */\r\n\r\n```\r\n\r\nSCSS는 각 줄에 `*`이 없어도 문제되지 않습니다. 따라서 기존 CSS와 호환이 쉽습니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n/*\r\n컴파일되는\r\n여러 줄\r\n주석\r\n*/\r\n\r\n```\r\n\r\n## 데이터 종류(Data Types)\r\n\r\n| 데이터 | 설명 | 예시 |\r\n| --- | --- | --- |\r\n| Numbers | 숫자 | `1`, `.82`, `20px`, `2em`… |\r\n| Strings | 문자 | `bold`, `relative`, `\"/images/a.png\"`, `\"dotum\"` |\r\n| Colors | 색상 표현 | `red`, `blue`, `#FFFF00`, `rgba(255,0,0,.5)` |\r\n| Booleans | 논리 | `true`, `false` |\r\n| Nulls | 아무것도 없음 | `null` |\r\n| Lists | 공백이나 `,`로 구분된 값의 목록 | `(apple, orange, banana)`, `apple orange` |\r\n| Maps | Lists와 유사하나 값이 `Key: Value` 형태 | `(apple: a, orange: o, banana: b)` |\r\n\r\n### 특이사항\r\n\r\nSass에서 사용하는 데이터 종류들의 몇 가지 특이사항을 소개합니다.\r\n\r\n-   Numbers: 숫자에 단위가 있거나 없습니다.\r\n-   Strings: 문자에 따옴표가 있거나 없습니다.\r\n-   Nulls: 속성값으로 `null`이 사용되면 컴파일하지 않습니다.\r\n-   Lists: `()`를 붙이거나 붙이지 않습니다.\r\n-   Maps: `()`를 꼭 붙여야 합니다.\r\n\r\n## 중첩(Nesting)\r\n\r\nSass는 중첩 기능을 사용할 수 있습니다.  \r\n상위 선택자의 반복을 피하고 좀 더 편리하게 복잡한 구조를 작성할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n.section {\r\n  width: 100%;\r\n  .list {\r\n    padding: 20px;\r\n    li {\r\n      float: left;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```css\r\n.section {\r\n  width: 100%;\r\n}\r\n.section .list {\r\n  padding: 20px;\r\n}\r\n.section .list li {\r\n  float: left;\r\n}\r\n\r\n```\r\n\r\n### Ampersand (상위 선택자 참조)\r\n\r\n중첩 안에서 `&` 키워드는 상위(부모) 선택자를 참조하여 치환합니다.\r\n\r\nSCSS:\r\n\r\n```css\r\n.btn {\r\n  position: absolute;\r\n  &.active {\r\n    color: red;\r\n  }\r\n}\r\n\r\n.list {\r\n  li {\r\n    &:last-child {\r\n      margin-right: 0;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.btn {\r\n  position: absolute;\r\n}\r\n.btn.active {\r\n  color: red;\r\n}\r\n.list li:last-child {\r\n  margin-right: 0;\r\n}\r\n\r\n```\r\n\r\n`&` 키워드가 참조한 상위 선택자로 치환되는 것이기 때문에 다음과 같이 응용할 수도 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.fs {\r\n  &-small { font-size: 12px; }\r\n  &-medium { font-size: 14px; }\r\n  &-large { font-size: 16px; }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fs-small {\r\n  font-size: 12px;\r\n}\r\n.fs-medium {\r\n  font-size: 14px;\r\n}\r\n.fs-large {\r\n  font-size: 16px;\r\n}\r\n\r\n```\r\n\r\n### @at-root (중첩 벗어나기)\r\n\r\n중첩에서 벗어나고 싶을 때 `@at-root` 키워드를 사용합니다.  \r\n중첩 안에서 생성하되 중첩 밖에서 사용해야 경우에 유용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.list {\r\n  $w: 100px;\r\n  $h: 50px;\r\n  li {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n  @at-root .box {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.list li {\r\n  width: 100px;\r\n  height: 50px;\r\n}\r\n.box {\r\n  width: 100px;\r\n  height: 50px;\r\n}\r\n\r\n```\r\n\r\n아래 예제 처럼 `.list` 안에 있는 특정 변수를 범위 밖에서 사용할 수 없기 때문에, 위 예제 처럼 `@at-root` 키워드를 사용해야 합니다.(변수는 아래에서 설명합니다)\r\n\r\n```\r\n.list {\r\n  $w: 100px;\r\n  $h: 50px;\r\n  li {\r\n    width: $w;\r\n    height: $h;\r\n  }\r\n}\r\n\r\n// Error\r\n.box {\r\n  width: $w;\r\n  height: $h;\r\n}\r\n\r\n```\r\n\r\n### 중첩된 속성\r\n\r\n`font-`, `margin-` 등과 같이 동일한 네임 스페이스를 가지는 속성들을 다음과 같이 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.box {\r\n  font: {\r\n    weight: bold;\r\n    size: 10px;\r\n    family: sans-serif;\r\n  };\r\n  margin: {\r\n    top: 10px;\r\n    left: 20px;\r\n  };\r\n  padding: {\r\n    bottom: 40px;\r\n    right: 30px;\r\n  };\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  font-weight: bold;\r\n  font-size: 10px;\r\n  font-family: sans-serif;\r\n  margin-top: 10px;\r\n  margin-left: 20px;\r\n  padding-bottom: 40px;\r\n  padding-right: 30px;\r\n}\r\n\r\n```\r\n\r\n## 변수(Variables)\r\n\r\n반복적으로 사용되는 값을 변수로 지정할 수 있습니다.  \r\n변수 이름 앞에는 항상 `$`를 붙입니다.\r\n\r\n```\r\n$변수이름: 속성값;\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$color-primary: #e96900;\r\n$url-images: \"/assets/images/\";\r\n$w: 200px;\r\n\r\n.box {\r\n  width: $w;\r\n  margin-left: $w;\r\n  background: $color-primary url($url-images + \"bg.jpg\");\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  width: 200px;\r\n  margin-left: 200px;\r\n  background: #e96900 url(\"/assets/images/bg.jpg\");\r\n}\r\n\r\n```\r\n\r\n### 변수 유효범위(Variable Scope)\r\n\r\n변수는 사용 가능한 유효범위가 있습니다.  \r\n선언된 블록(`{}`) 내에서만 유효범위를 가집니다.\r\n\r\n변수 `$color`는 `.box1`의 블록 안에서 설정되었기 때문에, 블록 밖의 `.box2`에서는 사용할 수 없습니다.\r\n\r\n```\r\n.box1 {\r\n  $color: #111;\r\n  background: $color;\r\n}\r\n// Error\r\n.box2 {\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\n### 변수 재 할당(Variable Reassignment)\r\n\r\n다음과 같이 변수에 변수를 할당할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$red: #FF0000;\r\n$blue: #0000FF;\r\n\r\n$color-primary: $blue;\r\n$color-danger: $red;\r\n\r\n.box {\r\n  color: $color-primary;\r\n  background: $color-danger;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  color: #0000FF;\r\n  background: #FF0000;\r\n}\r\n\r\n```\r\n\r\n### !global (전역 설정)\r\n\r\n`!global` 플래그를 사용하면 변수의 유효범위를 전역(Global)로 설정할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n.box1 {\r\n  $color: #111 !global;\r\n  background: $color;\r\n}\r\n.box2 {\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  background: #111;\r\n}\r\n.box2 {\r\n  background: #111;\r\n}\r\n\r\n```\r\n\r\n대신 기존에 사용하던 같은 이름의 변수가 있을 경우 값이 덮어져 사용될 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color: #000;\r\n.box1 {\r\n  $color: #111 !global;\r\n  background: $color;\r\n}\r\n.box2 {\r\n  background: $color;\r\n}\r\n.box3 {\r\n  $color: #222;\r\n  background: $color;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  background: #111;\r\n}\r\n.box2 {\r\n  background: #111;\r\n}\r\n.box3 {\r\n  background: #222;\r\n}\r\n\r\n```\r\n\r\n### !default (초깃값 설정)\r\n\r\n`!default` 플래그는 할당되지 않은 변수의 초깃값을 설정합니다.  \r\n즉, 할당되어있는 변수가 있다면 변수가 기존 할당 값을 사용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color-primary: red;\r\n\r\n.box {\r\n  $color-primary: blue !default;\r\n  background: $color-primary;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box {\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\n좀 더 유용하게, ‘변수와 값을 설정하겠지만, 혹시 기존 변수가 있을 경우는 현재 설정하는 변수의 값은 사용하지 않겠다’는 의미로 쓸 수 있습니다.  \r\n예를 들어, [Bootstrap](https://github.com/twbs/bootstrap/tree/v4-dev/scss) 같은 외부 Sass(SCSS) 라이브러리를 연결했더니 변수 이름이 같아 내가 작성한 코드의 변수들이 Overwrite(덮어쓰기) 된다면 문제가 있겠죠.  \r\n반대로 내가 만든 Sass(SCSS) 라이브러리가 다른 사용자 코드의 변수들을 Overwrite 한다면, 사용자들은 그 라이브러리를 더 이상 사용하지 않을 것입니다.  \r\n이럴 때 Sass(SCSS) 라이브러리(혹은 새롭게 만든 모듈)에서 사용하는 변수에 `!default` 플래그가 있다면 기존 코드(원본)를 Overwrite 하지 않고도 사용할 수 있습니다.\r\n\r\n```\r\n// _config.scss\r\n$color-active: red;\r\n\r\n```\r\n\r\n```\r\n// main.scss\r\n@import 'config';\r\n\r\n$color-active: blue !default;\r\n\r\n.box {\r\n  background: $color-active;  // red\r\n}\r\n\r\n```\r\n\r\n다음은 Bootstrap 코드([\\_variables.scss](https://github.com/twbs/bootstrap/blob/v4-dev/scss/_variables.scss))의 일부입니다.\r\n\r\n<script src=\"https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d.js\"></script>\r\n\r\n<table class=\"highlight tab-size js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\"><tbody><tr><td id=\"file-_variables-scss-L1\" class=\"blob-num js-line-number\" data-line-number=\"1\">&nbsp;</td><td id=\"file-_variables-scss-LC1\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-c\"><span class=\"pl-c\">//</span> stylelint-disable</span></td></tr><tr><td id=\"file-_variables-scss-L2\" class=\"blob-num js-line-number\" data-line-number=\"2\">&nbsp;</td><td id=\"file-_variables-scss-LC2\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$white</span>: <span class=\"pl-c1\">#fff</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L3\" class=\"blob-num js-line-number\" data-line-number=\"3\">&nbsp;</td><td id=\"file-_variables-scss-LC3\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-100</span>: <span class=\"pl-c1\">#f8f9fa</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L4\" class=\"blob-num js-line-number\" data-line-number=\"4\">&nbsp;</td><td id=\"file-_variables-scss-LC4\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-200</span>: <span class=\"pl-c1\">#e9ecef</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L5\" class=\"blob-num js-line-number\" data-line-number=\"5\">&nbsp;</td><td id=\"file-_variables-scss-LC5\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-300</span>: <span class=\"pl-c1\">#dee2e6</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L6\" class=\"blob-num js-line-number\" data-line-number=\"6\">&nbsp;</td><td id=\"file-_variables-scss-LC6\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-400</span>: <span class=\"pl-c1\">#ced4da</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L7\" class=\"blob-num js-line-number\" data-line-number=\"7\">&nbsp;</td><td id=\"file-_variables-scss-LC7\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-500</span>: <span class=\"pl-c1\">#adb5bd</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L8\" class=\"blob-num js-line-number\" data-line-number=\"8\">&nbsp;</td><td id=\"file-_variables-scss-LC8\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-600</span>: <span class=\"pl-c1\">#6c757d</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L9\" class=\"blob-num js-line-number\" data-line-number=\"9\">&nbsp;</td><td id=\"file-_variables-scss-LC9\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-700</span>: <span class=\"pl-c1\">#495057</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L10\" class=\"blob-num js-line-number\" data-line-number=\"10\">&nbsp;</td><td id=\"file-_variables-scss-LC10\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-800</span>: <span class=\"pl-c1\">#343a40</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L11\" class=\"blob-num js-line-number\" data-line-number=\"11\">&nbsp;</td><td id=\"file-_variables-scss-LC11\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$gray-900</span>: <span class=\"pl-c1\">#212529</span> <span class=\"pl-k\">!default</span>;</td></tr><tr><td id=\"file-_variables-scss-L12\" class=\"blob-num js-line-number\" data-line-number=\"12\">&nbsp;</td><td id=\"file-_variables-scss-LC12\" class=\"blob-code blob-code-inner js-file-line\"><span class=\"pl-v\">$black</span>: <span class=\"pl-c1\">#000</span> <span class=\"pl-k\">!default</span>;</td></tr></tbody></table>\r\n\r\n[view raw](https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d/raw/d1f8a93d7397ca4365feb29a2ede41653271a365/_variables.scss) [\\_variables.scss](https://gist.github.com/ParkYoungWoong/3c1c1c326a38753161e06e78c8264b3d#file-_variables-scss) hosted with ❤ by [GitHub](https://github.com)\r\n\r\n### #{} (문자 보간)\r\n\r\n`#{}`를 이용해서 코드의 어디든지 변수 값을 넣을 수 있습니다.\r\n\r\n```\r\n$family: unquote(\"Droid+Sans\");\r\n@import url(\"http://fonts.googleapis.com/css?family=#{$family}\");\r\n\r\n```\r\n\r\n```\r\n@import url(\"http://fonts.googleapis.com/css?family=Droid+Sans\");\r\n\r\n```\r\n\r\nSass의 내장 함수 `unquote()`는 문자에서 따옴표를 제거합니다.\r\n\r\n## 가져오기(Import)\r\n\r\n`@import`로 외부에서 가져온 Sass 파일은 모두 단일 CSS 출력 파일로 병합됩니다.  \r\n또한, 가져온 파일에 정의된 모든 변수 또는 Mixins 등을 주 파일에서 사용할 수 있습니다.\r\n\r\nSass `@import`는 기본적으로 Sass 파일을 가져오는데, CSS `@import` 규칙으로 컴파일되는 몇 가지 상황이 있습니다.\r\n\r\n-   파일 확장자가 `.css`일 때\r\n-   파일 이름이 `http://`로 시작하는 경우\r\n-   `url()`이 붙었을 경우\r\n-   미디어쿼리가 있는 경우\r\n\r\n위의 경우 CSS `@import` 규칙대로 컴파일 됩니다.\r\n\r\n```\r\n@import \"hello.css\";\r\n@import \"http://hello.com/hello\";\r\n@import url(hello);\r\n@import \"hello\" screen;\r\n\r\n```\r\n\r\n### 여러 파일 가져오기\r\n\r\n하나의 `@import`로 여러 파일을 가져올 수도 있습니다.  \r\n파일 이름은 `,`로 구분합니다.\r\n\r\n```\r\n@import \"header\", \"footer\";\r\n\r\n```\r\n\r\n### 파일 분할(Partials)\r\n\r\n프로젝트 규모가 커지면 파일들을 `header`나 `side-menu` 같이 각 기능과 부분으로 나눠 유지보수가 쉽도록 관리하게 됩니다.  \r\n이 경우 파일이 점점 많아지는데, 모든 파일이 컴파일 시 각각의 `~.css` 파일로 나눠서 저장된다면 관리나 성능 차원에서 문제가 될 수 있겠죠.  \r\n그래서 Sass는 Partials 기능을 지원합니다.  \r\n파일 이름 앞에 `_`를 붙여(`_header.scss`와 같이) `@import`로 가져오면 컴파일 시 `~.css` 파일로 컴파일하지 않습니다.\r\n\r\n예를 들어보겠습니다.  \r\n다음과 같이 `scss/` 안에 3개의 Sass 파일이 있습니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n`main.scss`로 나머지 `~.scss` 파일을 가져옵니다.\r\n\r\n```\r\n// main.scss\r\n@import \"header\", \"side-menu\";\r\n\r\n```\r\n\r\n그리고 이 파일들을 `css/`디렉토리로 컴파일합니다.  \r\n(컴파일은 위에서 설명한 `node-sass`로 진행합니다.)\r\n\r\n```\r\n# `scss`디렉토리에 있는 파일들을 `css`디렉토리로 컴파일\r\n$ node-sass scss --output css\r\n\r\n```\r\n\r\n컴파일 후 확인하면 아래와 같이 `scss/`에 있던 파일들이 `css/` 안에 각 하나씩의 파일로 컴파일됩니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─css\r\n  │  ├─header.css\r\n  │  ├─side-menu.css\r\n  │  └─main.css\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n자, 이번에는 가져올 파일 이름에 `_`를 붙이겠습니다.  \r\n메인 파일인 `main.scss`에서는 `_`를 사용하지 않습니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─scss\r\n  │  ├─_header.scss\r\n  │  ├─_side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n```\r\n// main.scss\r\n@import \"header\", \"side-menu\";\r\n\r\n```\r\n\r\n같은 방법으로 컴파일하면…\r\n\r\n```\r\n$ node-sass scss --output css\r\n\r\n```\r\n\r\n아래처럼 별도의 파일로 컴파일되지 않고 사용됩니다.\r\n\r\n```\r\nSass-App\r\n  # ...\r\n  ├─css\r\n  │  └─main.css  # main + header + side-menu\r\n  ├─scss\r\n  │  ├─header.scss\r\n  │  ├─side-menu.scss\r\n  │  └─main.scss\r\n  # ...\r\n\r\n```\r\n\r\n`Webpack`이나 `Parcel`, `Gulp` 같은 일반적인 빌드툴에서는 Partials 기능을 사용할 필요 없이, 설정된 값에 따라 빌드됩니다. 하지만 되도록 `_`를 사용할 것을 권장합니다.\r\n\r\n## 연산(Operations)\r\n\r\nSass는 기본적인 연산 기능을 지원합니다.  \r\n레이아웃 작업시 상황에 맞게 크기를 계산을 하거나 정해진 값을 나눠서 작성할 경우 유용합니다.  \r\n다음은 Sass에서 사용 가능한 연산자 종류 입니다.\r\n\r\n산술 연산자:\r\n\r\n| 종류 | 설명 | 주의사항 |\r\n| --- | --- | --- |\r\n| `+` | 더하기 |   |\r\n| `-` | 빼기 |   |\r\n| `*` | 곱하기 | 하나 이상의 값이 반드시 숫자(Number) |\r\n| `/` | 나누기 | 오른쪽 값이 반드시 숫자(Number) |\r\n| `%` | 나머지 |   |\r\n\r\n비교 연산자:\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `==` | 동등 |\r\n| `!=` | 부등 |\r\n| `<` | 대소 / 보다 작은 |\r\n| `>` | 대소 / 보다 큰 |\r\n| `<=` | 대소 및 동등 / 보다 작거나 같은 |\r\n| `>=` | 대소 및 동등 / 보다 크거나 같은 |\r\n\r\n논리(불린, Boolean) 연산자:\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `and` | 그리고 |\r\n| `or` | 또는 |\r\n| `not` | 부정 |\r\n\r\n### 숫자(Numbers)\r\n\r\n#### 상대적 단위 연산\r\n\r\n일반적으론 절댓값을 나타내는 `px` 단위로 연산을 합니다만, 상대적 단위(`%`, `em`, `vw` 등)의 연산의 경우 [CSS calc()](https://developer.mozilla.org/ko/docs/Web/CSS/calc)로 연산해야 합니다.\r\n\r\n```\r\nwidth: 50% - 20px;  // 단위 모순 에러(Incompatible units error)\r\nwidth: calc(50% - 20px);  // 연산 가능\r\n\r\n```\r\n\r\n#### 나누기 연산의 주의사항\r\n\r\nCSS는 속성 값의 숫자를 분리하는 방법으로 `/`를 허용하기 때문에 `/`가 나누기 연산으로 사용되지 않을 수 있습니다.  \r\n예를 들어, `font: 16px / 22px serif;` 같은 경우 `font-size: 16px`와 `line-height: 22px`의 속성값 분리를 위해서 `/`를 사용합니다.  \r\n아래 예제를 보면 나누기 연산자만 연산 되지 않고 그대로 컴파일됩니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  width: 20px + 20px;  // 더하기\r\n  height: 40px - 10px;  // 빼기\r\n  font-size: 10px * 2;  // 곱하기\r\n  margin: 30px / 2;  // 나누기\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 40px;  /* OK */\r\n  height: 30px;  /* OK */\r\n  font-size: 20px;  /* OK */\r\n  margin: 30px / 2;  /* ?? */\r\n}\r\n\r\n```\r\n\r\n따라서 `/`를 나누기 연산 기능으로 사용하려면 다음과 같은 조건을 충족해야 합니다.\r\n\r\n-   값 또는 그 일부가 변수에 저장되거나 함수에 의해 반환되는 경우\r\n-   값이 `()`로 묶여있는 경우\r\n-   값이 다른 산술 표현식의 일부로 사용되는 경우\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  $x: 100px;\r\n  width: $x / 2;  // 변수에 저장된 값을 나누기\r\n  height: (100px / 2);  // 괄호로 묶어서 나누기\r\n  font-size: 10px + 12px / 3;  // 더하기 연산과 같이 사용\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 50px;\r\n  height: 50px;\r\n  font-size: 14px;\r\n}\r\n\r\n```\r\n\r\n### 문자(Strings)\r\n\r\n문자 연산에는 `+`가 사용됩니다.  \r\n문자 연산의 결과는 첫 번째 피연산자를 기준으로 합니다.  \r\n첫 번째 피연산자에 따옴표가 붙어있다면 연산 결과를 따옴표로 묶습니다.  \r\n반대로 첫 번째 피연산자에 따옴표가 붙어있지 않다면 연산 결과도 따옴표를 처리하지 않습니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv::after {\r\n  content: \"Hello \" + World;\r\n  flex-flow: row + \"-reverse\" + \" \" + wrap\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv::after {\r\n  content: \"Hello World\";\r\n  flex-flow: row-reverse wrap;\r\n}\r\n\r\n```\r\n\r\n### 색상(Colors)\r\n\r\n색상도 연산할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\ndiv {\r\n  color: #123456 + #345678;\r\n  // R: 12 + 34 = 46\r\n  // G: 34 + 56 = 8a\r\n  // B: 56 + 78 = ce\r\n  background: rgba(50, 100, 150, .5) + rgba(10, 20, 30, .5);\r\n  // R: 50 + 10 = 60\r\n  // G: 100 + 20 = 120\r\n  // B: 150 + 30 = 180\r\n  // A: Alpha channels must be equal\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: #468ace;\r\n  background: rgba(60, 120, 180, 0.5);\r\n}\r\n\r\n```\r\n\r\nRGBA에서 Alpha 값은 연산되지 않으며 서로 동일해야 다른 값의 연산이 가능합니다.  \r\nAlpha 값을 연산하기 위한 다음과 같은 색상 함수(Color Functions)를 사용할 수 있습니다.\r\n\r\n[opacify()](http://sass-lang.com/documentation/Sass/Script/Functions.html#opacify-instance_method), [transparentize()](http://sass-lang.com/documentation/Sass/Script/Functions.html#transparentize-instance_method)\r\n\r\nSCSS:\r\n\r\n```\r\n$color: rgba(10, 20, 30, .5);\r\ndiv {\r\n  color: opacify($color, .3);  // 30% 더 불투명하게 / 0.5 + 0.3\r\n  background-color: transparentize($color, .2);  // 20% 더 투명하게 / 0.5 - 0.2\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: rgba(10, 20, 30, 0.8);\r\n  background-color: rgba(10, 20, 30, 0.3);\r\n}\r\n\r\n```\r\n\r\n### 논리(Boolean)\r\n\r\nSass의 `@if` 조건문에서 사용되는 논리(Boolean) 연산에는 ‘그리고’,’ 또는’, ‘부정’이 있습니다.  \r\n자바스크립트 문법에 익숙하다면 `&&`, `||`, `!`와 같은 기능으로 생각하면 됩니다.\r\n\r\n| 종류 | 설명 |\r\n| --- | --- |\r\n| `and` | 그리고 |\r\n| `or` | 또는 |\r\n| `not` | 부정(반대) |\r\n\r\n간단한 예제를 확인하고, 더 자세한 내용은 조건문에서 살펴보겠습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$width: 90px;\r\ndiv {\r\n  @if not ($width > 100px) {\r\n    height: 300px;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  height: 300px;\r\n}\r\n\r\n```\r\n\r\n## 재활용(Mixins)\r\n\r\nSass Mixins는 스타일 시트 전체에서 **재사용 할 CSS 선언 그룹** 을 정의하는 아주 훌륭한 기능입니다.  \r\n약간의 Mixin(믹스인)으로 다양한 스타일을 만들어낼 수 있습니다.\r\n\r\n우선, Mixin은 두 가지만 기억하면 됩니다.  \r\n선언하기(`@mixin`)와 포함하기(`@include`) 입니다.  \r\n만들어서(선언), 사용(포함)하는 거죠!\r\n\r\n### @mixin\r\n\r\n기본적인 Mixin 선언은 아주 간단합니다.  \r\n`@mixin` 지시어를 이용하여 스타일을 정의합니다.\r\n\r\n```\r\n// SCSS\r\n@mixin 믹스인이름 {\r\n  스타일;\r\n}\r\n\r\n// Sass\r\n=믹스인이름\r\n  스타일\r\n\r\n```\r\n\r\n```\r\n// SCSS\r\n@mixin large-text {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\n\r\n// Sass\r\n=large-text\r\n  font-size: 22px\r\n  font-weight: bold\r\n  font-family: sans-serif\r\n  color: orange\r\n\r\n```\r\n\r\nMixin은 선택자를 포함 가능하고 상위(부모) 요소 참조(`&` 같은)도 할 수 있습니다.\r\n\r\n```\r\n@mixin large-text {\r\n  font: {\r\n    size: 22px;\r\n    weight: bold;\r\n    family: sans-serif;\r\n  }\r\n  color: orange;\r\n\r\n  &::after {\r\n    content: \"!!\";\r\n  }\r\n\r\n  span.icon {\r\n    background: url(\"/images/icon.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n### @include\r\n\r\n선언된 Mixin을 사용(포함)하기 위해서는 `@include`가 필요합니다.  \r\n위에서 선언한 Mixin을 사용해 보겠습니다.\r\n\r\n```\r\n// SCSS\r\n@include 믹스인이름;\r\n\r\n// Sass\r\n+믹스인이름\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n// SCSS\r\nh1 {\r\n  @include large-text;\r\n}\r\ndiv {\r\n  @include large-text;\r\n}\r\n\r\n// Sass\r\nh1\r\n  +large-text\r\ndiv\r\n  +large-text\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\nh1 {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\nh1::after {\r\n  content: \"!!\";\r\n}\r\nh1 span.icon {\r\n  background: url(\"/images/icon.png\");\r\n}\r\n\r\ndiv {\r\n  font-size: 22px;\r\n  font-weight: bold;\r\n  font-family: sans-serif;\r\n  color: orange;\r\n}\r\ndiv::after {\r\n  content: \"!!\";\r\n}\r\ndiv span.icon {\r\n  background: url(\"/images/icon.png\");\r\n}\r\n\r\n```\r\n\r\n### 인수(Arguments)\r\n\r\nMixin은 함수(Functions)처럼 인수(Arguments)를 가질 수 있습니다.  \r\n하나의 Mixin으로 다양한 결과를 만들 수 있습니다.\r\n\r\n```\r\n// SCSS\r\n@mixin 믹스인이름($매개변수) {\r\n  스타일;\r\n}\r\n@include 믹스인이름(인수);\r\n\r\n// Sass\r\n=믹스인이름($매개변수)\r\n  스타일\r\n\r\n+믹스인이름(인수)\r\n\r\n```\r\n\r\n> 매개변수(Parameters)란 변수의 한 종류로, 제공되는 여러 데이터 중 하나를 가리키기 위해 사용된다.  \r\n> 제공되는 여러 데이터들을 전달인수(Arguments) 라고 부른다.\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin dash-line($width, $color) {\r\n  border: $width dashed $color;\r\n}\r\n\r\n.box1 { @include dash-line(1px, red); }\r\n.box2 { @include dash-line(4px, blue); }\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  border: 1px dashed red;\r\n}\r\n.box2 {\r\n  border: 4px dashed blue;\r\n}\r\n\r\n```\r\n\r\n#### 인수의 기본값 설정\r\n\r\n인수(argument)는 기본값(default value)을 가질 수 있습니다.  \r\n`@include` 포함 단계에서 별도의 인수가 전달되지 않으면 기본값이 사용됩니다.\r\n\r\n```\r\n@mixin 믹스인이름($매개변수: 기본값) {\r\n  스타일;\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin dash-line($width: 1px, $color: black) {\r\n  border: $width dashed $color;\r\n}\r\n\r\n.box1 { @include dash-line; }\r\n.box2 { @include dash-line(4px); }\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  border: 1px dashed black;\r\n}\r\n.box2 {\r\n  border: 4px dashed black;\r\n}\r\n\r\n```\r\n\r\n#### 키워드 인수(Keyword Arguments)\r\n\r\n```\r\n@mixin 믹스인이름($매개변수A: 기본값, $매개변수B: 기본값) {\r\n  스타일;\r\n}\r\n\r\n@include 믹스인이름($매개변수B: 인수);\r\n\r\n```\r\n\r\nMixin에 전달할 인수를 입력할 때 명시적으로 키워드(변수)를 입력하여 작성할 수 있습니다.  \r\n별도의 인수 입력 순서를 필요로 하지 않아 편리하게 작성할 수 있습니다.  \r\n단, 작성하지 않은 인수가 적용될 수 있도록 기본값을 설정해 주는 것이 좋습니다.\r\n\r\n```\r\n@mixin position(\r\n  $p: absolute,\r\n  $t: null,\r\n  $b: null,\r\n  $l: null,\r\n  $r: null\r\n) {\r\n  position: $p;\r\n  top: $t;\r\n  bottom: $b;\r\n  left: $l;\r\n  right: $r;\r\n}\r\n\r\n.absolute {\r\n  // 키워드 인수로 설정할 값만 전달\r\n  @include position($b: 10px, $r: 20px);\r\n}\r\n.fixed {\r\n  // 인수가 많아짐에 따라 가독성을 확보하기 위해 줄바꿈\r\n  @include position(\r\n    fixed,\r\n    $t: 30px,\r\n    $r: 40px\r\n  );\r\n}\r\n\r\n```\r\n\r\n```\r\n.absolute {\r\n  position: absolute;\r\n  bottom: 10px;\r\n  right: 20px;\r\n}\r\n.fixed {\r\n  position: fixed;\r\n  top: 30px;\r\n  right: 40px;\r\n}\r\n\r\n```\r\n\r\n#### 가변 인수(Variable Arguments)\r\n\r\n때때로 입력할 인수의 개수가 불확실한 경우가 있습니다.  \r\n그럴 경우 가변 인수를 사용할 수 있습니다.  \r\n가변 인수는 매개변수 뒤에 `...`을 붙여줍니다.\r\n\r\n```\r\n@mixin 믹스인이름($매개변수...) {\r\n  스타일;\r\n}\r\n\r\n@include 믹스인이름(인수A, 인수B, 인수C);\r\n\r\n```\r\n\r\n```\r\n// 인수를 순서대로 하나씩 전달 받다가, 3번째 매개변수($bg-values)는 인수의 개수에 상관없이 받음\r\n@mixin bg($width, $height, $bg-values...) {\r\n  width: $width;\r\n  height: $height;\r\n  background: $bg-values;\r\n}\r\n\r\ndiv {\r\n  // 위의 Mixin(bg) 설정에 맞게 인수를 순서대로 전달하다가 3번째 이후부터는 개수에 상관없이 전달\r\n  @include bg(\r\n    100px,\r\n    200px,\r\n    url(\"/images/a.png\") no-repeat 10px 20px,\r\n    url(\"/images/b.png\") no-repeat,\r\n    url(\"/images/c.png\")\r\n  );\r\n}\r\n\r\n```\r\n\r\n```\r\ndiv {\r\n  width: 100px;\r\n  height: 200px;\r\n  background: url(\"/images/a.png\") no-repeat 10px 20px,\r\n              url(\"/images/b.png\") no-repeat,\r\n              url(\"/images/c.png\");\r\n}\r\n\r\n```\r\n\r\n위에선 인수를 받는 매개변수에 `...`을 사용하여 가변 인수를 활용했습니다.  \r\n이번엔 반대로 가변 인수를 전달할 값으로 사용해 보겠습니다.\r\n\r\n```\r\n@mixin font(\r\n  $style: normal,\r\n  $weight: normal,\r\n  $size: 16px,\r\n  $family: sans-serif\r\n) {\r\n  font: {\r\n    style: $style;\r\n    weight: $weight;\r\n    size: $size;\r\n    family: $family;\r\n  }\r\n}\r\ndiv {\r\n  // 매개변수 순서와 개수에 맞게 전달\r\n  $font-values: italic, bold, 16px, sans-serif;\r\n  @include font($font-values...);\r\n}\r\nspan {\r\n  // 필요한 값만 키워드 인수로 변수에 담아 전달\r\n  $font-values: (style: italic, size: 22px);\r\n  @include font($font-values...);\r\n}\r\na {\r\n  // 필요한 값만 키워드 인수로 전달\r\n  @include font((weight: 900, family: monospace)...);\r\n}\r\n\r\n```\r\n\r\n```\r\ndiv {\r\n  font-style: italic;\r\n  font-weight: bold;\r\n  font-size: 16px;\r\n  font-family: sans-serif;\r\n}\r\nspan {\r\n  font-style: italic;\r\n  font-weight: normal;\r\n  font-size: 22px;\r\n  font-family: sans-serif;\r\n}\r\na {\r\n  font-style: normal;\r\n  font-weight: 900;\r\n  font-size: 16px;\r\n  font-family: monospace;\r\n}\r\n\r\n```\r\n\r\n### @content\r\n\r\n선언된 Mixin에 `@content`이 포함되어 있다면 해당 부분에 원하는 **스타일 블록** 을 전달할 수 있습니다.  \r\n이 방식을 사용하여 기존 Mixin이 가지고 있는 기능에 선택자나 속성 등을 추가할 수 있습니다.\r\n\r\n```\r\n@mixin 믹스인이름() {\r\n  스타일;\r\n  @content;\r\n}\r\n\r\n@include 믹스인이름() {\r\n  // 스타일 블록\r\n  스타일;\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin icon($url) {\r\n  &::after {\r\n    content: $url;\r\n    @content;\r\n  }\r\n}\r\n.icon1 {\r\n  // icon Mixin의 기존 기능만 사용\r\n  @include icon(\"/images/icon.png\");\r\n}\r\n.icon2 {\r\n  // icon Mixin에 스타일 블록을 추가하여 사용\r\n  @include icon(\"/images/icon.png\") {\r\n    position: absolute;\r\n  };\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.icon1::after {\r\n  content: \"/images/icon.png\";\r\n}\r\n.icon2::after {\r\n  content: \"/images/icon.png\";\r\n  position: absolute;\r\n}\r\n\r\n```\r\n\r\nMixin에게 전달된 스타일 블록은 Mixin의 범위가 아니라 스타일 블록이 정의된 범위에서 평가됩니다.  \r\n즉, Mixin의 매개변수는 전달된 스타일 블록 안에서 사용되지 않고 전역 값으로 해석됩니다.  \r\n전역 변수(Global variables)와 지역 변수(Local variables)를 생각하면 좀 더 쉽습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$color: red;\r\n\r\n@mixin colors($color: blue) {\r\n  // Mixin의 범위\r\n  @content;\r\n  background-color: $color;\r\n  border-color: $color;\r\n}\r\n\r\ndiv {\r\n  @include colors() {\r\n    // 스타일 블록이 정의된 범위\r\n    color: $color;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: red;\r\n  background-color: blue;\r\n  border-color: blue;\r\n}\r\n\r\n```\r\n\r\n## 확장(Extend)\r\n\r\n특정 선택자가 다른 선택자의 모든 스타일을 가져야하는 경우가 종종 있습니다.  \r\n이럴 경우 선택자의 확장 기능을 사용할 수 있습니다.  \r\n다음 예제를 봅시다.\r\n\r\n```\r\n@extend 선택자;\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n.btn {\r\n  padding: 10px;\r\n  margin: 10px;\r\n  background: blue;\r\n}\r\n.btn-danger {\r\n  @extend .btn;\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.btn, .btn-danger {\r\n  padding: 10px;\r\n  margin: 10px;\r\n  background: blue;\r\n}\r\n.btn-danger {\r\n  background: red;\r\n}\r\n\r\n```\r\n\r\n컴파일된 결과가 마음에 드시나요?  \r\n결과를 보면 `,`로 구분하는 다중 선택자(Multiple Selector)가 만들어졌습니다.\r\n\r\n사실 `@extend`는 다음과 같은 문제를 고려해야 합니다.\r\n\r\n-   내 현재 선택자(위 예제의 `.btn-danger`)가 어디에 첨부될 것인가?\r\n-   원치 않는 부작용이 초래될 수도 있는가?\r\n-   이 한 번의 확장으로 얼마나 큰 CSS가 생성되는가?\r\n\r\n결과적으로 확장(Extend) 기능은 무해하거나 혹은 유익할 수도 있지만 그만큼 **부작용**을 가지고 있을 수 있습니다.  \r\n따라서 확장은 사용을 권장하지 않으며, 위에서 살펴본 **Mixin을 대체 기능으로 사용**하세요.\r\n\r\n사용을 권장하지 않는 이유에 대해서 좀 더 자세한 정보를 원하면 [Sass Guidelines Extend](https://sass-guidelin.es/ko/#extend)를 참고하세요.\r\n\r\n## 함수(Functions)\r\n\r\n자신의 함수를 정의하여 사용할 수 있습니다.  \r\n함수와 Mixins은 거의 유사하지만 반환되는 내용이 다릅니다.\r\n\r\nMixin은 위에서 살펴본 대로 지정한 스타일(Style)을 반환하는 반면,  \r\n함수는 보통 연산된(Computed) 특정 **값**을 `@return` 지시어를 통해 반환합니다.\r\n\r\n```\r\n// Mixins\r\n@mixin 믹스인이름($매개변수) {\r\n  스타일;\r\n}\r\n\r\n// Functions\r\n@function 함수이름($매개변수) {\r\n  @return 값\r\n}\r\n\r\n```\r\n\r\n사용하는 방법에도 차이가 있습니다.  \r\nMixin은 `@include` 지시어를 사용하는 반면,  \r\n함수는 함수이름으로 바로 사용합니다.\r\n\r\n```\r\n// Mixin\r\n@include 믹스인이름(인수);\r\n\r\n// Functions\r\n함수이름(인수)\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$max-width: 980px;\r\n\r\n@function columns($number: 1, $columns: 12) {\r\n  @return $max-width * ($number / $columns)\r\n}\r\n\r\n.box_group {\r\n  width: $max-width;\r\n\r\n  .box1 {\r\n    width: columns();  // 1\r\n  }\r\n  .box2 {\r\n    width: columns(8);\r\n  }\r\n  .box3 {\r\n    width: columns(3);\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box_group {\r\n  /* 총 너비 */\r\n  width: 980px;\r\n}\r\n.box_group .box1 {\r\n  /* 총 너비의 약 8.3% */\r\n  width: 81.66667px;\r\n}\r\n.box_group .box2 {\r\n  /* 총 너비의 약 66.7% */\r\n  width: 653.33333px;\r\n}\r\n.box_group .box3 {\r\n  /* 총 너비의 25% */\r\n  width: 245px;\r\n}\r\n\r\n```\r\n\r\n위와 같이 함수는 `@include` 같은 별도의 지시어 없이 사용하기 때문에 내가 지정한 함수와 내장 함수(Built-in Functions)의 이름이 충돌할 수 있습니다.  \r\n따라서 내가 지정한 함수에는 별도의 접두어를 붙여주는 것이 좋습니다.\r\n\r\n> 내장 함수란, 응용 프로그램에 내장되어 있으며 최종 사용자가 액세스 할 수 있는 기능입니다.  \r\n> 예를 들어, 대부분의 스프레드 시트 응용 프로그램은 행이나 열의 모든 셀을 추가하는 내장 SUM 함수를 지원합니다.\r\n\r\n예를 들어, 색의 빨강 성분을 가져오는 내장 함수로 이미 `red()`가 있습니다.  \r\n같은 이름을 사용하여 함수를 정의하면 이름이 충돌하기 때문에 별도의 접두어를 붙여 `extract-red()` 같은 이름을 만들 수 있습니다.\r\n\r\n```\r\n// 내가 정의한 함수\r\n@function extract-red($color) {\r\n  // 내장 함수\r\n  @return rgb(red($color), 0, 0);\r\n}\r\n\r\ndiv {\r\n  color: extract-red(#D55A93);\r\n}\r\n\r\n```\r\n\r\n혹은 모든 내장 함수의 이름을 다 알고 있을 수 없기 때문에 특별한 이름을 접두어로 사용할 수도 있습니다.  \r\n`my-custom-func-red()`\r\n\r\n## 조건과 반복(Control Directives / Expressions)\r\n\r\n### if (함수)\r\n\r\n조건의 값(`true`, `false`)에 따라 두 개의 표현식 중 하나만 반환합니다.  \r\n[조건부 삼항 연산자(conditional ternary operator)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)와 비슷합니다.\r\n\r\n조건의 값이 `true`이면 `표현식1`을,  \r\n조건의 값이 `false`이면 `표현식2`를 실행합니다.\r\n\r\n```\r\nif(조건, 표현식1, 표현식2)\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$width: 555px;\r\ndiv {\r\n  width: if($width > 300px, $width, null);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 555px;\r\n}\r\n\r\n```\r\n\r\n### @if (지시어)\r\n\r\n`@if` 지시어는 조건에 따른 분기 처리가 가능하며, [if 문(if statements)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/if...else)과 유사합니다.  \r\n같이 사용할 수 있는 지시어는 `@else`, `if`가 있습니다.  \r\n추가 지시어를 사용하면 좀 더 복잡한 조건문을 작성할 수 있습니다.\r\n\r\n```\r\n// @if\r\n@if (조건) {\r\n  /* 조건이 참일 때 구문 */\r\n}\r\n\r\n// @if @else\r\n@if (조건) {\r\n  /* 조건이 참일 때 구문 */\r\n} @else {\r\n  /* 조건이 거짓일 때 구문 */\r\n}\r\n\r\n// @if @else if\r\n@if (조건1) {\r\n  /* 조건1이 참일 때 구문 */\r\n} @else if (조건2) {\r\n  /* 조건2가 참일 때 구문 */\r\n} @else {\r\n  /* 모두 거짓일 때 구문 */\r\n}\r\n\r\n```\r\n\r\n조건에 `()`는 생략이 가능하기 때문에, `()` 없이 작성하는 방법이 좀 더 편리할 수 있습니다.\r\n\r\n```\r\n$bg: true;\r\ndiv {\r\n  @if $bg {\r\n    background: url(\"/images/a.jpg\");\r\n  }\r\n}\r\n\r\n```\r\n\r\nSCSS:\r\n\r\n```\r\n$color: orange;\r\ndiv {\r\n  @if $color == strawberry {\r\n    color: #FE2E2E;\r\n  } @else if $color == orange {\r\n    color: #FE9A2E;\r\n  } @else if $color == banana {\r\n    color: #FFFF00;\r\n  } @else {\r\n    color: #2A1B0A;\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  color: #FE9A2E;\r\n}\r\n\r\n```\r\n\r\n조건에는 논리 연산자 `and`, `or`, `not`을 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n@function limitSize($size) {\r\n  @if $size >= 0 and $size <= 200px {\r\n    @return 200px;\r\n  } @else {\r\n    @return 800px;\r\n  }\r\n}\r\n\r\ndiv {\r\n  width: limitSize(180px);\r\n  height: limitSize(340px);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\ndiv {\r\n  width: 200px;\r\n  height: 800px;\r\n}\r\n\r\n```\r\n\r\n좀 더 복잡하지만 실용적인 예제를 봅시다.  \r\nSass의 내장 함수 `unitless()`는 숫자에 단위가 있는지 여부를 반환합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n@mixin pCenter($w, $h, $p: absolute) {\r\n  @if\r\n    $p == absolute\r\n    or $p == fixed\r\n    or not $p == relative\r\n    or not $p == static\r\n  {\r\n    width: if(unitless($w), #{$w}px, $w);\r\n    height: if(unitless($h), #{$h}px, $h);\r\n    position: $p;\r\n    top: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    margin: auto;\r\n  }\r\n}\r\n\r\n.box1 {\r\n  @include pCenter(10px, 20px);\r\n}\r\n.box2 {\r\n  @include pCenter(50, 50, fixed);\r\n}\r\n.box3 {\r\n  @include pCenter(100, 200, relative);\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box1 {\r\n  width: 10px;\r\n  height: 20px;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  margin: auto;\r\n}\r\n\r\n.box2 {\r\n  width: 50px;\r\n  height: 50px;\r\n  position: fixed;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  margin: auto;\r\n}\r\n\r\n```\r\n\r\n### @for\r\n\r\n`@for`는 스타일을 반복적으로 출력합니다.  \r\n[for 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for)과 유사합니다.\r\n\r\n`@for`는 `through`를 사용하는 형식과 `to`를 사용하는 형식으로 나뉩니다.  \r\n두 형식은 종료 조건이 해석되는 방식이 다릅니다.\r\n\r\n```\r\n// through\r\n// 종료 만큼 반복\r\n@for $변수 from 시작 through 종료 {\r\n  // 반복 내용\r\n}\r\n\r\n// to\r\n// 종료 직전까지 반복\r\n@for $변수 from 시작 to 종료 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n차이점을 이해하기 위해 다음 예제를 살펴봅시다.  \r\n변수는 관례상 `$i`를 사용합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n// 1부터 3번 반복\r\n@for $i from 1 through 3 {\r\n  .through:nth-child(#{$i}) {\r\n    width : 20px * $i\r\n  }\r\n}\r\n\r\n// 1부터 3 직전까지만 반복(2번 반복)\r\n@for $i from 1 to 3 {\r\n  .to:nth-child(#{$i}) {\r\n    width : 20px * $i\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.through:nth-child(1) { width: 20px; }\r\n.through:nth-child(2) { width: 40px; }\r\n.through:nth-child(3) { width: 60px; }\r\n\r\n.to:nth-child(1) { width: 20px; }\r\n.to:nth-child(2) { width: 40px; }\r\n\r\n```\r\n\r\n`to`는 주어진 값 직전까지만 반복해야할 경우 유용할 수 있습니다.  \r\n그러나 `:nth-child()`에서 특히 유용하게 사용되는 `@for`는 일반적으로 `through`를 사용하길 권장합니다.\r\n\r\n### @each\r\n\r\n`@each`는 List와 Map 데이터를 반복할 때 사용합니다.  \r\n[for in 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...in)과 유사합니다.\r\n\r\n```\r\n@each $변수 in 데이터 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\nList 데이터를 반복해 보겠습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n// List Data\r\n$fruits: (apple, orange, banana, mango);\r\n\r\n.fruits {\r\n  @each $fruit in $fruits {\r\n    li.#{$fruit} {\r\n      background: url(\"/images/#{$fruit}.png\");\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fruits li.apple {\r\n  background: url(\"/images/apple.png\");\r\n}\r\n.fruits li.orange {\r\n  background: url(\"/images/orange.png\");\r\n}\r\n.fruits li.banana {\r\n  background: url(\"/images/banana.png\");\r\n}\r\n.fruits li.mango {\r\n  background: url(\"/images/mango.png\");\r\n}\r\n\r\n```\r\n\r\n혹시 매번 반복마다 Index 값이 필요하다면 다음과 같이 `index()` 내장 함수를 사용할 수 있습니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$fruits: (apple, orange, banana, mango);\r\n\r\n.fruits {\r\n  @each $fruit in $fruits {\r\n    $i: index($fruits, $fruit);\r\n    li:nth-child(#{$i}) {\r\n      left: 50px * $i;\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.fruits li:nth-child(1) {\r\n  left: 50px;\r\n}\r\n.fruits li:nth-child(2) {\r\n  left: 100px;\r\n}\r\n.fruits li:nth-child(3) {\r\n  left: 150px;\r\n}\r\n.fruits li:nth-child(4) {\r\n  left: 200px;\r\n}\r\n\r\n```\r\n\r\n동시에 여러 개의 List 데이터를 반복 처리할 수도 있습니다.  \r\n단, 각 데이터의 Length가 같아야 합니다.\r\n\r\nSCSS:\r\n\r\n```\r\n$apple: (apple, korea);\r\n$orange: (orange, china);\r\n$banana: (banana, japan);\r\n\r\n@each $fruit, $country in $apple, $orange, $banana {\r\n  .box-#{$fruit} {\r\n    background: url(\"/images/#{$country}.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\nCompiled to:\r\n\r\n```\r\n.box-apple {\r\n  background: url(\"/images/korea.png\");\r\n}\r\n.box-orange {\r\n  background: url(\"/images/china.png\");\r\n}\r\n.box-banana {\r\n  background: url(\"/images/japan.png\");\r\n}\r\n\r\n```\r\n\r\nMap 데이터를 반복할 경우 하나의 데이터에 두 개의 변수가 필요합니다.\r\n\r\n```\r\n@each $key변수, $value변수 in 데이터 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n```\r\n$fruits-data: (\r\n  apple: korea,\r\n  orange: china,\r\n  banana: japan\r\n);\r\n\r\n@each $fruit, $country in $fruits-data {\r\n  .box-#{$fruit} {\r\n    background: url(\"/images/#{$country}.png\");\r\n  }\r\n}\r\n\r\n```\r\n\r\n```\r\n.box-apple {\r\n  background: url(\"/images/korea.png\");\r\n}\r\n.box-orange {\r\n  background: url(\"/images/china.png\");\r\n}\r\n.box-banana {\r\n  background: url(\"/images/japan.png\");\r\n}\r\n\r\n```\r\n\r\n### @while\r\n\r\n`@while`은 조건이 `false`로 평가될 때까지 내용을 반복합니다.  \r\n[while 문](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/while)과 유사하게 잘못된 조건으로 인해 컴파일 중 무한 루프에 빠질 수 있습니다.  \r\n사용을 권장하지 않습니다.\r\n\r\n```\r\n@while 조건 {\r\n  // 반복 내용\r\n}\r\n\r\n```\r\n\r\n```\r\n$i: 6;\r\n\r\n@while $i > 0 {\r\n  .item-#{$i} {\r\n    width: 2px * $i;\r\n  }\r\n  $i: $i - 2;\r\n}\r\n\r\n```\r\n\r\n```\r\n.item-6 { width: 12px; }\r\n.item-4 { width: 8px; }\r\n.item-2 { width: 4px; }\r\n\r\n```\r\n\r\n## 내장 함수(Built-in Functions)\r\n\r\nSass에서 기본적으로 제공하는 내장 함수에는 많은 종류가 있습니다.  \r\n모두 소개하지 않고, 주관적 경험에 의거해 필요하거나 필요할 수 있는 함수만 정리했습니다.\r\n\r\n[Sass Built-in Functions](http://sass-lang.com/documentation/Sass/Script/Functions.html)에서 모든 내장 함수를 확인할 수 있습니다.\r\n\r\n-   `[]`는 선택 가능한 인수(argument)입니다.\r\n-   [Zero-based numbering](https://en.wikipedia.org/wiki/Zero-based_numbering)을 사용하지 않습니다.\r\n\r\n### 색상(RGB / HSL / Opacity) 함수\r\n\r\n[mix($color1, $color2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method) : 두 개의 색을 섞습니다.\r\n\r\n[lighten($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#lighten-instance_method) : 더 밝은색을 만듭니다.\r\n\r\n[darken($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#darken-instance_method) : 더 어두운색을 만듭니다.\r\n\r\n[saturate($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#saturate-instance_method) : 색상의 채도를 올립니다.\r\n\r\n[desaturate($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#desaturate-instance_method) : 색상의 채도를 낮춥니다.\r\n\r\n[grayscale($color)](http://sass-lang.com/documentation/Sass/Script/Functions.html#grayscale-instance_method) : 색상을 회색으로 변환합니다.\r\n\r\n[invert($color)](http://sass-lang.com/documentation/Sass/Script/Functions.html#invert-instance_method) : 색상을 반전시킵니다.\r\n\r\n[rgba($color, $alpha)](http://sass-lang.com/documentation/Sass/Script/Functions.html#rgba-instance_method) : 색상의 투명도를 변경합니다.\r\n\r\n[opacify($color, $amount) / fade-in($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#opacify-instance_method) : 색상을 더 불투명하게 만듭니다.\r\n\r\n[transparentize($color, $amount) / fade-out($color, $amount)](http://sass-lang.com/documentation/Sass/Script/Functions.html#transparentize-instance_method) : 색상을 더 투명하게 만듭니다.\r\n\r\n### 문자(String) 함수\r\n\r\n[unquote($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unquote-instance_method) : 문자에서 따옴표를 제거합니다.\r\n\r\n[quote($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#quote-instance_method) : 문자에 따옴표를 추가합니다.\r\n\r\n[str-insert($string, $insert, $index)](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_insert-instance_method) : 문자의 index번째에 특정 문자를 삽입합니다.\r\n\r\n[str-index($string, $substring)](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_index-instance_method) : 문자에서 특정 문자의 첫 index를 반환합니다.\r\n\r\n[str-slice($string, $start-at, \\[$end-at\\])](http://sass-lang.com/documentation/Sass/Script/Functions.html#str_slice-instance_method) : 문자에서 특정 문자(몇 번째 글자부터 몇 번째 글자까지)를 추출합니다.\r\n\r\n[to-upper-case($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#to_upper_case-instance_method) : 문자를 대문자를 변환합니다.\r\n\r\n[to-lower-case($string)](http://sass-lang.com/documentation/Sass/Script/Functions.html#to_lower_case-instance_method) : 문자를 소문자로 변환합니다.\r\n\r\n### 숫자(Number) 함수\r\n\r\n[percentage($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#percentage-instance_method) : 숫자(단위 무시)를 백분율로 변환합니다.\r\n\r\n[round($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#round-instance_method) : 정수로 반올림합니다.\r\n\r\n[ceil($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#ceil-instance_method) : 정수로 올림합니다.\r\n\r\n[floor($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#floor-instance_method) : 정수로 내림(버림)합니다.\r\n\r\n[abs($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#abs-instance_method) : 숫자의 절대 값을 반환합니다.\r\n\r\n[min($numbers…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#min-instance_method) : 숫자 중 최소 값을 찾습니다.\r\n\r\n[max($numbers…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#max-instance_method) : 숫자 중 최대 값을 찾습니다.\r\n\r\n[random()](http://sass-lang.com/documentation/Sass/Script/Functions.html#random-instance_method) : `0` 부터 `1` 사이의 난수를 반환합니다.\r\n\r\n### List 함수\r\n\r\n모든 List 내장 함수는 기존 List 데이터를 갱신하지 않고 새 List 데이터를 반환합니다.  \r\n모든 List 내장 함수는 Map 데이터에서도 사용할 수 있습니다.\r\n\r\n[length($list)](http://sass-lang.com/documentation/Sass/Script/Functions.html#length-instance_method) : List의 개수를 반환합니다.\r\n\r\n[nth($list, $n)](http://sass-lang.com/documentation/Sass/Script/Functions.html#nth-instance_method) : List에서 n번째 값을 반환합니다.\r\n\r\n[set-nth($list, $n, $value)](http://sass-lang.com/documentation/Sass/Script/Functions.html#set_nth-instance_method) : List에서 n번째 값을 다른 값으로 변경합니다.\r\n\r\n[join($list1, $list2, \\[$separator\\])](http://sass-lang.com/documentation/Sass/Script/Functions.html#join-instance_method) : 두 개의 List를 하나로 결합합니다.\r\n\r\n[zip($lists…)](http://sass-lang.com/documentation/Sass/Script/Functions.html#zip-instance_method) : 여러 List들을 하나의 다차원 List로 결합합니다.\r\n\r\n[index($list, $value)](http://sass-lang.com/documentation/Sass/Script/Functions.html#index-instance_method) : List에서 특정 값의 index를 반환합니다.\r\n\r\n### Map 함수\r\n\r\n모든 Map 내장 함수는 기존 Map 데이터를 갱신하지 않고 새 Map 데이터를 반환합니다.\r\n\r\n[map-get($map, $key)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_get-instance_method) : Map에서 특정 key의 value를 반환합니다.\r\n\r\n[map-merge($map1, $map2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_merge-instance_method) : 두 개의 Map을 병합하여 새로운 Map를 만듭니다.\r\n\r\n[map-keys($map)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_keys-instance_method) : Map에서 모든 key를 List로 반환합니다.\r\n\r\n[map-values($map)](http://sass-lang.com/documentation/Sass/Script/Functions.html#map_values-instance_method) : Map에서 모든 value를 List로 반환합니다.\r\n\r\n### 관리(Introspection) 함수\r\n\r\n[variable-exists(name)](http://sass-lang.com/documentation/Sass/Script/Functions.html#variable_exists-instance_method) : 변수가 현재 범위에 존재하는지 여부를 반환합니다.(인수는 `$`없이 변수의 이름만 사용합니다.)\r\n\r\n[unit($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unit-instance_method) : 숫자의 단위를 반환합니다.\r\n\r\n[unitless($number)](http://sass-lang.com/documentation/Sass/Script/Functions.html#unitless-instance_method) : 숫자에 단위가 있는지 여부를 반환합니다.\r\n\r\n[comparable($number1, $number2)](http://sass-lang.com/documentation/Sass/Script/Functions.html#comparable-instance_method) : 두 개의 숫자가 연산 가능한지 여부를 반환합니다.\r\n\r\n# 참고 자료(References)\r\n\r\n[http://sass-lang.com/documentation](http://sass-lang.com/documentation)  \r\n[https://www.sitepoint.com/sass-basics-operators/](https://www.sitepoint.com/sass-basics-operators/)  \r\n[https://sass-guidelin.es/ko/](https://sass-guidelin.es/ko/)  \r\n[http://www.thesassway.com/](http://www.thesassway.com/)","memberId":1,"boardId":3,"regDate":"2020-12-20 01:25:13","updateDate":"2021-01-15 20:54:38","extra_writer":"D.K","extra_boardName":"html&CSS","extra_boardCode":"html&CSS","rcmCount":2,"hit":2,"commentsCount":4}]}